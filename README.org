#+TITLE:  My Emacs Configuration
#+AUTHOR: Diego Vicente Martín
#+EMAIL:  diegovicente@protonmail.com

* Introduction

The idea generating a new configuration file using ~org-mode~ and literate
programming is taken from [[https://youtu.be/SzA2YODtgK4][Harry Schwartz's talk about org-mode]]. When Emacs is
booted, all the source blocks from this file are used to generate the
configuration file.

To do this, the only thing needed is to have the configuration file parsed and
evaluated on startup. This can be done by moving ~init.el~ to the ~emacs.d~
directory. This can be done by executing =cp init.el ~/.emacs.d/init.el= on the
terminal. Note: this file assumes that this repository has been cloned to your
home, if you are going to install it elsewhere please edit ~init.el~ to find
this file.

* Basic Emacs Setup
** My information

All the relevant and personal information that Emacs needs. If you are going to
use it, needless to say to use your own information.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Diego Vicente"
      user-mail-address "diegovicente@protonmail.com"
      calendar-latitude 40.33
      calendar-longitude -3.76
      calendar-location-name "Madrid, Spain")
#+END_SRC

** Add MELPA

The main package repository for Emacs. Must have, probably all the packages
that you need are already in MELPA. Also, check that it is HTTPS! We'll
elaborate on it in a bit.

#+BEGIN_SRC emacs-lisp
;; Add MELPA
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   '("MELPA" . "https://melpa.org/packages/") t)
  (package-initialize))
#+END_SRC

** Making Emacs secure

Some safety tips regarding your editor are covered in the excellent article
[[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Your Text Editor is Malware]]. So, before going on with the configuration, let's
get some things straight. First of all, enable checking trust on TLS
connections.

#+BEGIN_SRC emacs-lisp
(setq tls-checktrust t)
#+END_SRC

Now that we have enabled this feature, Emacs can't fetch HTTPS anymore: Emacs
does not distribute trust root certificates. So let's try to put a remedy for
it. First, there are some things you need to install outside of Emacs: the
~certifi~ package for ~PyPI~ using ~python3 -m pip install --user certifi~ and
~gnutls~ by running ~brew install gnutls~ or ~apt-get install gnutls-bin~. Once
we have everything set, we just need to tell Emacs where to search for the
tools: setting the ~tls-program~ variable.

#+BEGIN_SRC emacs-lisp
;; This snippet is ready to work in both UNIX-like and Windows OS
(let ((trustfile
       (replace-regexp-in-string
        "\\\\" "/"
        (replace-regexp-in-string
         "\n" ""
         (shell-command-to-string (concat "python3 -m certifi"))))))
  (setq tls-program
        (list
         (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                 (if (eq window-system 'w32) ".exe" "") trustfile)))
  (setq gnutls-verify-error t)
  (setq gnutls-trustfiles (list trustfile)))
#+END_SRC

And, just in case (specially since the blog post provided it), we can create a
function to check if this setup is properly done:

#+BEGIN_SRC emacs-lisp
(defun check-tls-config ()
  "Check for correctness in the TLS configuration for Emacs."
  (interactive)
  (let ((bad-hosts
		 (cl-loop for bad
			   in `("https://wrong.host.badssl.com/"
					"https://self-signed.badssl.com/")
			   if (condition-case e
					  (url-retrieve
					   bad (lambda (retrieved) t))
					(error nil))
			   collect bad)))
	(if bad-hosts
		(error (format "TLS misconfigured; retrieved %s ok" bad-hosts))
	  (url-retrieve "https://badssl.com"
					(lambda (retrieved) t)))))
#+END_SRC

Please note that it is *crucial* to have added MELPA as an HTTPS for this
secure configuration to work.

** Disable ~yes-or-no~ messages

For some reason, there are different types of confirmation prompts in
Emacs. One of them forces you to write "yes" and the other one only to press
"y", so I disable the first type.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable startup message

I simply prefer to have a scratch buffer ready when I boot up, with ~org-mode~
running. Not a great Lisp developer myself (yet).

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil
      initial-major-mode 'org-mode)
#+END_SRC

** Disable the warning when killing a buffer w/ process

When a buffer (i.e ~something.py~) has an associated process (in that case,
~Python~ for completion), Emacs will prompt you when trying to kill it, asking
for confirmation. I think it just interferes in my way, so I disable it as
well.

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+END_SRC

** Disable the bell

It is incredibly annoying after 20 minutes.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Set the backups folder

This feature is super useful sometimes, but it kills me to swarm my projects
with ~foo~~ files. That's why I set them to a backup directory and stop them
from polluting everywhere.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
  backup-by-copying t    ; Don't delink hardlinks
  version-control t      ; Use version numbers on backups
  delete-old-versions t  ; Automatically delete excess backups
  kept-new-versions 20   ; how many of the newest versions to keep
  kept-old-versions 5    ; and how many of the old
  )
#+END_SRC

** Fill the ~exec-path~ variable

I spent too much time until I figured this out. Since I mostly use GUI Emacs,
the ~exec-path~ variable is empty at start (it has not been started through
shell). That's why we need a function to loading the contents of ~$PATH~ to
Emacs variable and call it at start. This function was improved and uploaded as
package to MELPA, so to install it:

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :demand t
  :config (exec-path-from-shell-initialize))
#+END_SRC

** Insert new line without breaking

One of the things I really miss from vim is the shortcut ~o~, which was used to
insert a new line below the line in which the cursor is. To have the same
behavior in Emacs, I found this custom function that I bound to ~C-o~.

#+BEGIN_SRC emacs-lisp
(defun insert-new-line-below ()
  "Add a new line below the current line"
  (interactive)
  (let ((oldpos (point)))
    (end-of-line)
    (newline-and-indent)))

(global-set-key (kbd "C-o") 'insert-new-line-below)
#+END_SRC

** Move buffers around

If we want to swap buffers location in frames, there's no fast way to do it in
Emacs by default. To do it, a good option that I found is to use ~buffer-move~
package, and use these key bindings.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("C-x w <up>"    . buf-move-up)
         ("C-x w <down>"  . buf-move-down)
         ("C-x w <left>"  . buf-move-left)
         ("C-x w <right>" . buf-move-right)))
#+END_SRC

** Redefining sentences in Emacs

Emacs allows you to move in sentences using the commands ~M-a~ and ~M-e~ (to go
to the beginning or the end of the sentence). This is super useful for editing
text, but Emacs assumes that you always end sentences using a period and /two/
whitespaces, which... I actually don't. We can override this behavior with:

#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)
#+END_SRC

** Auto-fill comments

For our comments (only comments, not code) to be automatically filled
in programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
      (setq-local comment-auto-fill-only-comments t)
      (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** More intuitive regions


This makes the visual region behave more like the contemporary concept of
highlighted text, that can be erased or overwritten as a whole.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Add functions to determine system

To know in which system we are running, I use these functions:

#+BEGIN_SRC emacs-lisp
(defun system-is-mac ()
  (interactive)
  (string-equal system-type "darwin"))

(defun system-is-linux ()
  (interactive)
  (string-equal system-type "gnu/linux"))

(defun system-is-chip ()
  (interactive)
  (string-equal system-name "chip"))
#+END_SRC

** Define keybindings to ~eval-buffer~ on init and open ~README.org~

Before this magical ~org~ configuration, it was easier to reload Emacs
configuration on the fly: ~M-x eval-buffer RET~. However, now the buffer to
evaluate is not this one, but ~.emacs.d/init.el~. That's why it's probably a
better idea to define a new keybinding that automatically reloads that buffer.

#+BEGIN_SRC emacs-lisp
(defun reload-emacs-configuration()
  "Reload the configuration"
  (interactive)
    (load "~/.emacs.d/init.el"))

(defun open-emacs-configuration ()
  "Open the configuration.org file in buffer"
  (interactive)
    (find-file "~/my-emacs/README.org"))

(global-set-key (kbd "C-c c r") 'reload-emacs-configuration)
(global-set-key (kbd "C-c c o") 'open-emacs-configuration)
#+END_SRC

** Scroll in the compilation buffer

It is really annoying to not have the last part of the output in the screen
when compiling. This automatically scrolls the buffer for you as the output is
printed.

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output t)
#+END_SRC

** Add other keybindings

Miscellaneous keybindings that don't really fit anywhere else.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c b") 'bookmark-jump)
#+END_SRC

* My own Emacs-Lisp functions
** Clean the buffer

This function cleans the buffer from trailing whitespaces, more than two
consecutive new lines and tabs.

#+BEGIN_SRC emacs-lisp
(defun my-clean-buffer ()
  "Cleans the buffer by re-indenting, removing tabs and trailing whitespace."
  (interactive)
  (delete-trailing-whitespace)
  (save-excursion
    (replace-regexp "^\n\\{3,\\}" "\n\n" nil (point-min) (point-max)))
  (untabify (point-min) (point-max)))

(global-set-key (kbd "C-c x") 'my-clean-buffer)
#+END_SRC

** Move to indentation or beginning of the line

By default, ~C-c a~ moves the cursor to the beginning of the line. If there is
indentation, usually you want to move to the beginning of the line after the
indentation, which is indeed bound by default to ~M-m~. However, my muscle
memory seems to be unable to learn that those are two different actions, so
it's time to use some Emacs magic. ~beginning-of-line-dwim~ takes you to the
beginning of indentation, as ~M-m~ would do. If you are already there, it takes
you to the absolute beginning of the line.

#+BEGIN_SRC emacs-lisp
(defun beginning-of-line-dwim ()
  (interactive)
  "Move to beginning of indentation, if there move to beginning of line."
  (if (= (point) (progn (back-to-indentation) (point)))
	  (beginning-of-line)))

(global-set-key (kbd "C-a") 'beginning-of-line-dwim)
#+END_SRC

** Set the fringe as the background

This function allows to set the fringe color the same as the background, which
makes it look flatter and more minimalist.

#+BEGIN_SRC emacs-lisp
(defun set-fringe-as-background ()
  "Force the fringe to have the same color as the background"
  (set-face-attribute 'fringe nil
                      :foreground (face-foreground 'default)
                      :background (face-background 'default)))
#+END_SRC

** Change light and dark themes

Since I don't simply load a theme, but a lot of customization along with it, I
need to load the different themes in whole functions. That way, when I want to
switch from one to the other, I prevent the hand-tuned things to crash.

#+BEGIN_SRC emacs-lisp
(defun load-common-setup ()
  "Set all the faces that are prepared for both light and dark themes"
  (set-face-foreground 'git-gutter:modified "#fabd2f")
  (set-face-foreground 'git-gutter:added    "#b8bb26")
  (set-face-foreground 'git-gutter:deleted  "#fb4933")
  (set-face-attribute 'font-lock-doc-face nil :inherit 'shadow)
  (set-face-attribute 'org-ellipsis nil :underline nil)
  (set-fringe-as-background))

(defun load-dark-theme ()
  "Load the theme gruvbox-dark-medium and other custom faces."
  (interactive)
  (load-theme 'gruvbox-dark-medium t)
  (load-common-setup)
  (set-face-foreground 'shadow "#a89984")
  (set-face-attribute 'mode-line nil
					  :box '(:line-width 5 :color "#665c54"))
  (set-face-attribute 'mode-line-inactive nil
					  :box '(:line-width 5 :color "#3c3836"))
  (org-bullets-mode)
  (org-bullets-mode))

(defun load-light-theme ()
  "Load the theme gruvbox-light-medium and other custom faces."
  (interactive)
  (load-theme 'gruvbox-light-soft t)
  (load-common-setup)
  (set-face-foreground 'shadow "#7c6f64")
  (set-face-attribute 'mode-line nil
					  :box '(:line-width 5 :color "#bdae93"))
  (set-face-attribute 'mode-line-inactive nil
					  :box '(:line-width 5 :color "#ebdbb2"))
  (org-bullets-mode)
  (org-bullets-mode))

(global-set-key (kbd "C-c c d") 'load-dark-theme)
(global-set-key (kbd "C-c c l") 'load-light-theme)
#+END_SRC

* Graphical Interface
** Disabling GUI defaults

I always use Emacs in its GUI client, but because of the visual capabilities
and not the tools and bars. That's why I like to disable all the graphical
clutter.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Start in full-screen

If we are running on Mac, this snippet launches the native fullscreen; if not
it just maximizes the first frame we create.

#+BEGIN_SRC emacs-lisp
(if (system-is-mac)
    (set-frame-parameter nil 'fullscreen 'fullboth)
  (setq initial-frame-alist '((fullscreen . maximized))))
#+END_SRC

** Setting default font

I really like how condensed is [[https://github.com/be5invis/Iosevka][Iosevka]], a coding typeface. Although it may look
weird in the beginning, then it's a joy to have all your code properly fitting
in the screen. However, lately I have really been into Liberation Mono, Fira
Mono, Office Code Pro and Roboto Mono. All great, readable fonts.

#+BEGIN_SRC emacs-lisp
(if (system-is-chip)
    (set-default-font "Liberation Mono 8" t t)
(set-default-font "Roboto Mono 13" t t))
;; (set-default-font "Office Code Pro 13" t t))
#+END_SRC

** Highlight changed and uncommited lines

Use the ~git-gutter-fringe~ package for that. For me it's more than enough to
have it in programming modes and in ~org-mode~.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure git-gutter-fringe
  :delight
  :config
  (add-hook 'prog-mode-hook 'git-gutter-mode)
  (add-hook 'org-mode-hook 'git-gutter-mode))
#+END_SRC

Since we are using Gruvbox theme all along, I prefer to tweak the colors to
make them softer, using some red, green and yellow from the color palette.

** ~delight~ to manage mode names in the mode-line

This package let us rename or hide mode names in the mode-line, with the great
advantage of being fully compatible with ~use-package~.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :ensure t
  :demand t)
#+END_SRC

Since Emacs provides some minor modes that I want to hide as well, we will add
a weird declaration to maintain the coherence:

#+BEGIN_SRC emacs-lisp
(use-package emacs
  :delight
  (auto-revert-mode)
  (auto-fill-function)
  (visual-line-mode))
#+END_SRC

** Setting my favorite theme

I really like [[https://github.com/chriskempson/base16][base16 color themes]] by Chris Kempson, specially Eighties.
However, lately I am really enjoying Gruvbox themes lately. They are available
in MELPA. We also use the ~NO-CONFIRM~ flag when loading, since the file
tangling probably makes the code be not in order for ~custom-set-variables~ to
do its job.

#+BEGIN_SRC emacs-lisp
(use-package gruvbox-theme
  :ensure t
  :config (load-dark-theme))
#+END_SRC

** ~smart-mode-line~ configuration

~smart-mode-line~ allows us to do a greater configuration of the mode-line
without being as flashy (and accessible tbh). This is the bare-bones
configuration for the package, that makes it not even load a theme. Apart from
the mere aesthetics, I also configure the column number display and different
short names for my folders. The last part edits slightly the mode line by
adding a single white-space below the fringe, which helps when rendering.

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :config
  (progn
    ;; Basic
    (setq sml/theme nil)
    (sml/setup)
    (setq sml/no-confirm-load-theme t)
    ;; Format the line string
    (setq-default mode-line-format
      '(" %e"
        mode-line-front-space
        mode-line-mule-info
        mode-line-client
        mode-line-modified
        mode-line-remote
        mode-line-frame-identification
        mode-line-buffer-identification
        sml/pos-id-separator
        mode-line-position
        (vc-mode vc-mode)
        sml/pre-modes-separator
        mode-line-modes
        mode-line-misc-info
        mode-line-end-spaces))
    ;; Shorthands and column number
    (column-number-mode 1)
    (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/Projects/" ":PRJ:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/org/" ":ORG:" ))
    (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/org/bibliography/"
                                             ":BIB:" ))
    ))
#+END_SRC

** Configure modes in mode line to be shorter

~cyphejor~ is a package that allows to make shorter names in the
mode-line. And, as you can see, my way to use it is maybe a little bit
aggressive.

#+BEGIN_SRC emacs-lisp
(use-package cyphejor
  :ensure t
  :config
  (progn
    (setq
     cyphejor-rules
     '(:upcase
       ("bookmark"    "→")
       ("buffer"      "β")
       ("diff"        "Δ")
       ("dired"       "δ")
       ("emacs"       "ε")
       ("fundamental" "Ⓕ")
       ("inferior"    "i" :prefix)
       ("interaction" "i" :prefix)
       ("interactive" "i" :prefix)
       ("lisp"        "λ" :postfix)
       ("menu"        "▤" :postfix)
       ("haskell"     "λ=")
       ("mode"        "")
       ("package"     "↓")
       ("python"      "π")
       ("org"         "Ω")
       ("shell"       "sh" :postfix)
       ("text"        "ξ")))
    (cyphejor-mode 1)))
#+END_SRC

** Set the cursor as a vertical bar

This is less agressive than the default brick, for sure. Thanks [[https://github.com/Alexrs95][Alex]] for this
snippet!

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
#+END_SRC

** Adding icons with ~all-the-icons~

This package comes with a set of icons gathered from different fonts, so they
can be used basically everywhere. At least in macOS, remember to install the
necessary fonts that come bundled in the package!

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons
  :ensure t)
#+END_SRC

* Packages & Tools
** ~which-key~

A beautiful package that helps a lot specially when you are new to Emacs. Every
time a key chord is started, it displays all possible outcomes in the
minibuffer.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :delight
  :ensure t
  :config (which-key-mode))
#+END_SRC

** ~neotree~

I used the default ~dired~ for a long time, but I found that ~neotree~ adds
less clutter normally. I also set the theme for the icons using
~all-the-icons~. Since I have already the muscle memory, I just override
~dired~'s regular binding to open ~neotree~.

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :delight
  :ensure t
  :config (setq neo-theme (if (display-graphic-p) 'icons 'arrow)))
#+END_SRC

** ~ivy~

After trying ~ido~ and ~helm~, the only step left to try was ~ivy~. The way it
works is more similar to ~ido~: it is a completion engine but more minimalist
than ~helm~, simpler and faster.

#+BEGIN_SRC emacs-lisp
(use-package ivy
  :ensure t
  :demand t
  :delight
  :config (ivy-mode 1)
  :bind (("C-s" . swiper)
		 ("C-c h f" . counsel-describe-function)
		 ("C-c h v" . counsel-describe-variable)
		 :map ivy-minibuffer-map
		 ("RET" . ivy-alt-done)
		 ("C-j" . ivy-done)))
#+END_SRC

** ~magit~


A porcelain client for git. ~magit~ alone is a reason to use Emacs over
vi/vim. It is really wonderful to use and you should install right now. This
also binds the status function to ~C-x g~.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :delight
  :ensure t
  :bind (("C-x g" . magit-status)))
#+END_SRC

** ~projectile~

Enables different tools and functions to deal with files related to a
project. To work, it searches for a VCS and sets it as the root of a project. I
have it configured to ignore all files that has not been staged in the git
project.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :delight
  :config
  (projectile-global-mode 1)
  (setq projectile-use-git-grep t))
#+END_SRC

Also, the extension ~counsel-projectile~ adds integration with ~ivy~.

#+BEGIN_SRC emacs-lisp
(use-package counsel-projectile
  :ensure t
  :delight
  :config (counsel-projectile-on))
#+END_SRC

** ~perspective~

This package lets us store the window distributions that we use and switch
between them. I like to use it with ~persp-projectile~, which creates
perspectives automatically integrating them with each project. To configure it:

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :demand t
  :delight
  :config
  (persp-mode)
  :bind (:map projectile-mode-map
			  ("C-c p f" . counsel-git)
			  ("C-c p n" . persp-next)
			  ("C-c p k" . kill-current-perspective)))

(use-package persp-projectile
  :ensure t
  :demand t)
#+END_SRC

This snippet also changes the color of the mode-line widget to a smoother one
and binds ~C-c p n~ to change next perspective to integrate better the
perspective and project management.

Now that we have defined this beautiful ~perspective~ + ~projectile~ combo, we
can tweak a bit more its integration: For example, we can override the
behavior of ~C-c p k~: by default it is ~projectile-kill-buffers~, that will
kill all buffers associated to a project. We can make it also delete the
associated perspective:

#+BEGIN_SRC emacs-lisp
(defun kill-current-perspective ()
  "Kill the current project buffers and close its perspective."
  (interactive)
  (persp-kill (persp-name persp-curr)))
#+END_SRC

It is important to use ~define-key~ to shadow ~projectile~'s own bindings.

** ~flycheck~

Checks syntax for different languages. Works wonders, even though sometimes has
to be configured because it really makes things slow.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :delight
  :config 
  (add-hook 'prog-mode-hook #'flycheck-mode)
  (set-face-underline 'flycheck-error '(:color "Red1" :style line)))
#+END_SRC

** ~flyspell~

Just like ~flycheck~, but it checks natural language in a text. Super useful
for note taking and other text edition, specially if you use Emacs for
everything like I do. ~flyspell~ is installed in new Emacs versions, but there
are no completion tools by default in macOS, so we need to install the ~aspell~
engine by running ~brew install aspell --with-lang-en~

To make ~flyspell~ not clash with different syntax in the same file (like for
example, LaTeX or ~org-mode~ one) we need the last hook message.


#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :delight
  :config
  (progn
    (setq ispell-program-name "aspell"
          ispell-dictionary "english")
    (add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))))
#+END_SRC

In case I am writing a text in a different language, I can just use ~M-x
ispell-change-dictionary~. Emacs seems to have a wide enough range of
dictionaries preinstalled to suit my needs. Later in the configurations, hooks
are added to each of the major-modes where I want ~flyspell~ to work.

And this function prevents the spell checker to get inside source blocks in
~org~.

#+BEGIN_SRC emacs-lisp
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let* ((rlt ad-return-value)
         (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (case-fold-search t)
         b e)
    (when ad-return-value
      (save-excursion
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t))))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

** ~company~

It is a light-weight completion system, supposed to be faster and simpler than
good 'ol ~auto-complete~.

#+BEGIN_SRC emacs-lisp
(use-package company
  :delight
  :ensure t)
#+END_SRC

** ~auto-complete~

It is probably redundant with ~company~, but works like a charm for the Python
environment. This bare-bones config just enables auto completion for language
specific words and other words in the buffer, so it's not really super useful.
For language specific settings, check each of the langauge configs. Also, I
like to customize a bit the looks of the pop-up menu

#+BEGIN_SRC emacs-lisp
;; (use-package auto-complete-config
;;   :disabled
;;   :ensure auto-complete
;;   :config
;;   (progn
;;     (ac-config-default)
;;     (setq ac-show-menu-immediately-on-auto-complete t)
;;     (set-face-attribute 'popup-summary-face nil :inherit 'popup-face)
;;     (set-face-attribute 'popup-tip-face nil
;;                         :foreground "#c0c5ce"
;;                         :background "#4f5b66")))
#+END_SRC

** ~smartparens~

Auto-close parenthesis and other characters. Useful as it seems. Also, I add a
new custom pair that makes it indent and pass the closing pair when a newline
is inserted right after a curly bracket. This is specially useful in C and Go.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :delight
  :config
  (add-hook 'prog-mode-hook #'smartparens-mode)
  (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
#+END_SRC

** ~expand-region~

Expand region allows to select hierarchically different text regions. It is, in
a way, a replacement for vim text objects.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :delight
  :bind (("C-=" . er/expand-region)))
#+END_SRC

** Bind ~eshell~

I don't use shell as much as I did before customizing Emacs, but still a good
command line is the best option sometimes. Bound it to ~C-c t~ and use all the
shortcuts of Emacs inside of it!

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c t") 'eshell)
#+END_SRC

** ~iedit~

This tool allows us to edit all variable names at once just by entering a
single keystroke.

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :ensure t
  :delight
  :bind (("C-c i" . iedit-mode)))
#+END_SRC

** ~easy-escape~

Makes Lisp regular expressions more readable.

#+BEGIN_SRC emacs-lisp
(use-package easy-escape
  :ensure t
  :delight
  :config
  (progn
    (add-hook 'lisp-mode-hook 'easy-escape-minor-mode)
    (add-hook 'emacs-lisp-mode-hook 'easy-escape-minor-mode)
	))
#+END_SRC

** ~undo-tree~

This awesome package enables a gret undo-redo system that includes creating new
undo-redo branches. It's really amazing.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :delight
  :config (global-undo-tree-mode))
#+END_SRC

** ~yasnippets~

This package is a template and snippet system for Emacs, inspired by the syntax
of TextMate.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :delight
  :config
  (progn
    (add-to-list 'yas-snippet-dirs "~/my-emacs/snippets")
    (yas-global-mode 1)
    (advice-add 'yas--auto-fill-wrapper :override #'ignore)))
#+END_SRC

In the ~/snippets~ folder in this repository you can see my snippets
collection. A good guide to understand the syntax used is in [[https://joaotavora.github.io/yasnippet/snippet-development.html][the manual for
YASnippet]]. All the snippets are local to a certain mode (delimited by the name
of the folder in the collection) and their keys can be expanded using ~TAB~.

** Rainbow delimiters

This package turns the parenthesis into color pairs, which makes everything
easier (specially in Lisp)

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :delight
  :config (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

* Programming Modes
** Python

#+BEGIN_SRC emacs-lisp
(use-package elpy
  :ensure t
  :delight
  :config
  (elpy-enable)
  (elpy-use-ipython)
  (add-to-list 'python-shell-completion-native-disabled-interpreters "ipython")
  (setq python-shell-interpreter-args "--simple-prompt -i")
  (add-hook 'elpy-mode-hook (lambda () (highlight-indentation-mode -1))))
#+END_SRC

** Haskell
*** Enable ~intero~

In my experience, trying to deal with ~haskell-mode~ head-on is a pain in the
ass, and makes programming really slow. However, ~intero~ is a package with
batteries-included that works wonders. The best idea is to install it and hook
it to Haskell.

#+BEGIN_SRC emacs-lisp
(use-package intero
  :ensure t
  :init   (setenv "PATH" (concat "/usr/local/bin/ghci" (getenv "PATH")))
  :config (add-hook 'haskell-mode-hook 'intero-mode))
#+END_SRC

*** Disable soft wrapping in profiling files

GHC generates ~.prof~ files, which sometimes tend to have really long lines. To
make it easier to read them, I like to disable line truncation for that file
extension. The problem is that, well, is not as straightforward as you may
think...

#+BEGIN_SRC emacs-lisp
(add-hook 'find-file-hook
		  (lambda ()
			(when (and (stringp buffer-file-name)
					   (string-match "\\.prof\\'" buffer-file-name))
			  (toggle-truncate-lines))))
#+END_SRC

** Idris

Idris is a relatively new language: purely functional, general purpose, and
oriented to type development and with a type and totality checker integrated. I
think that it is a super interesting experiment but a good Emacs configuration
makes it look like absolute magic.

#+BEGIN_SRC emacs-lisp
(use-package idris-mode
  :delight
  :ensure t
  :bind (:map idris-mode-map
			  ("C-c C-a" . idris-add-clause)
			  ("C-c C-s" . idris-case-split)
			  ("C-c C-f" . idris-proof-search)))
#+END_SRC

With this config, we can use a type-define-refine cycle by using the keys =C-c
C-a= to add a clause associated with a type definition, =C-c C-s= to split
cases and =C-c C-f= to fill a hole if possible; which is easier for me to
remember.

** Go

I am a complete noob in Go, and I have been trying to hack a bit with it
lately. This is just a little disclaimer taking into account that this is just
a leisure configuration and if you are going to manage code on production maybe
you need a different configuration to face it.

*** Installing and configuring ~go-mode~

The first recommendation for a Go major mode seems to be this one:

#+BEGIN_SRC emacs-lisp
(use-package go-mode
  :ensure t)
#+END_SRC

*** Set tab width

Since Go is not precisely characterized by its open-mindedness, we have to use
tabs in our code (sigh). So, at least, let's set its size to something that can
be read (4 instead 8 characters long)

#+BEGIN_SRC emacs-lisp
(setq-default tab-width 4)
#+END_SRC

*** Calling ~go-fmt~ on save

We can use hooks to automatically format our code according to the guidelines:

#+BEGIN_SRC emacs-lisp
(add-to-list 'exec-path "/Users/diego/go")
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

*** Adding the ~company~ backend

Making auto-completion work in Go requires:

#+BEGIN_SRC emacs-lisp
(use-package company-go
  :ensure t
  :config
  (add-hook 'go-mode-hook 'company-mode)
  (add-to-list 'company-backends 'company-go))
#+END_SRC

*** Viewing documentation in the minibuffer

Using ~go-eldoc~ we can see the declaration, arguments, return types, etc of
the functions we are using in our code.

#+BEGIN_SRC emacs-lisp
(use-package go-eldoc
  :ensure t
  :config (add-hook 'go-mode-hook 'go-eldoc-setup))
#+END_SRC

*** Enabling playgrounds in Emacs

Go playgrounds enable a kind of REPL, which is super useful when trying to
learn the language and fast iterate over some code snippets.

#+BEGIN_SRC emacs-lisp
(use-package go-playground
  :ensure t)
#+END_SRC

** LaTeX

With this configuration, we try to aim for a WYSIWYG editor in Emacs. It
requires to have ~AUCTeX~ installed.

*** Basic ~AUCTeX~ setup

This snippet makes that the ~AUCTeX~ macros are loaded every time the editor
requires them.

#+BEGIN_SRC emacs-lisp
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq TeX-save-query nil)
(setq-default TeX-master nil)
;(setq TeX-PDF-mode t)
#+END_SRC

*** Enable ~flyspell~ in Tex edition

Add the hook to enable it by default.

#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-buffer)
#+END_SRC

*** Enable auto-fill for Tex edition

We already enabled auto-fill for comments in programming modes, but in LaTeX is
more useful to directly have everything auto-filled.

#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'auto-fill-mode)
#+END_SRC

*** Adding ~company~ support for Tex

Add the backend enable auto-completion for LaTeX files.

#+BEGIN_SRC emacs-lisp
(use-package company-auctex
  :ensure t
  :config 
  (add-hook 'LaTeX-mode-hook 'company-mode)
  (company-auctex-init))
#+END_SRC

* ~org-mode~
** Basic setup and other habits
*** Enable ~auto-fill-mode~ in Emacs

I truly believe that code and other text files have to respect a 79 characters
per line bound. No, 120 is not enough. Of course, for me ~org-mode~ should also
be, so we enable this behaviour to be automatic. Also, keep in mind that Emacs
auto fills to 70 characters, so we have to manually set the 79 limit.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
(setq-default fill-column 79)
#+END_SRC

*** Ensure LaTeX export options

We need to ensure that the indentation is left unaltered when exporting to
LaTeX, and also to add several options for ~org-ref~ exporting to work properly

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)

(setq org-latex-default-packages-alist
      (-remove-item
       '("" "hyperref" nil)
       org-latex-default-packages-alist))

(add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
(add-to-list 'org-latex-default-packages-alist
             '("linktocpage,pdfstartview=FitH,colorlinks,
linkcolor=blue,anchorcolor=blue,
citecolor=blue,filecolor=blue,menucolor=blue,urlcolor=blue"
               "hyperref" nil)
             t)
#+END_SRC

*** Native ~TAB~ in source blocks

This option makes ~TAB~ work as if the keystroke was issued in the code's major
mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

*** Open source blocks in the same window

When editing source code in an ~org~ source block, we can open a new buffer to
edit the code in its major mode. This option makes it use the same window
instead of popping a new one.

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
#+END_SRC

*** Set the directory

I set my org-directory in Dropbox. In there is the agenda files as well.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org")

(defun org-file-path (filename)
  "Return the absolute address of an org file, given its relative name."
  (concat (file-name-as-directory org-directory) filename))

(setq org-agenda-files (list (org-file-path "master.org")
							 (org-file-path "agenda.org")))
#+END_SRC

*** Better RET

While reading this post in [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][the Kitchin Research Group website]], I stumbled into
this package that allows a better behavior of ~RET~ in ~org-mode~.

#+BEGIN_SRC emacs-lisp
(use-package org-autolist
  :ensure t
  :delight
  :config (add-hook 'org-mode-hook (lambda () (org-autolist-mode))))
#+END_SRC

*** Formatting functions

I have defined several functions to help me format text using the org markup
language. When I have selected text, I can use those keybindings to surround
the text with the different signs.

#+BEGIN_SRC emacs-lisp
(defun org-mode-format-bold (&optional arg)
  "Surround the selected text with asterisks (bold)"
  (interactive "P")
  (insert-pair arg ?\* ?\*))

(defun org-mode-format-italics (&optional arg)
  "Surround the selcted text with forward slashes (italics)"
  (interactive "P")
  (insert-pair arg ?\/ ?\/))

(defun org-mode-format-tt (&optional arg)
  "Surround the selcted text with virgules (monotype)"
  (interactive "P")
  (insert-pair arg ?\~ ?\~))


(add-hook 'org-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c f b") 'org-mode-format-bold)
            (local-set-key (kbd "C-c f i") 'org-mode-format-italics)
            (local-set-key (kbd "C-c f m") 'org-mode-format-tt)))
#+END_SRC

*** Keybinding for ~org-agenda~

I like to have an easy access to the agenda, so I'll just bind it to ~C-c a~.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c a") 'org-agenda)
#+END_SRC

** Graphical aspects
*** Use syntax highlight in source blocks

When writing source code on a block, if this variable is enabled it will use
the same syntax highlight as the mode supposed to deal with it.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

*** Enable ~org-bullets~

Enable ~org-bullets~ to make it clearer. Also, the defaults are maybe
a bit too much for me, so edit them.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :delight
  :config
  (progn
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
    (setq org-bullets-bullet-list
          '("◉" "◎" "○" "○" "○" "○"))))
#+END_SRC

*** Custom ellipsis

Also, I don't really like ~...~ to be the symbol for an ~org~ ellipsis. I
prefer to set something much more visual:

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ⤵")
#+END_SRC

*** Pretty symbols

This setting will make subscripts (~x_{subscript}~) and superscripts
(~x^{superscript}~) appear in ~org~ in a WYSIWYG fashion.

#+BEGIN_SRC emacs-lisp
(setq-default org-pretty-entities t)
#+END_SRC

** Spell checking

Add spell checking by enabling ~flyspell~ in its buffers. The configuration for
~flyspell~ is above.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'flyspell-mode)
;(add-hook 'org-mode-hook 'flyspell-buffer)
#+END_SRC

** ~org-ref~

~org-ref~ is a great package that enables a great deal of references and
shortcuts in ~org-mode~ when exporting to different formats like HTML or
LaTeX. The configuration can be a bit of a pain in the ass:

*** Basic setup and default dirs

We require the packages and set the default for the bibliography notes, the
main ~.bib~ bibliography and the directory where the PDFs can be downloaded to.

#+BEGIN_SRC emacs-lisp
;; (use-package org-ref-pdf
;;   :ensure t)

;; (use-package org-ref-url-utils
;;   :ensure t)

(use-package org-ref
  :ensure t
  :delight
  :config
  (progn
    (setq org-ref-bibliography-notes "~/Dropbox/org/bibliography/notes.org"
          org-ref-default-bibliography '("~/Dropbox/org/bibliography/main.bib")
          org-ref-pdf-directory "~/Dropbox/org/bibliography/pdfs"
          org-latex-pdf-process
          '("pdflatex -interaction nonstopmode -output-directory %o %f"
            "bibtex %b"
            "pdflatex -interaction nonstopmode -output-directory %o %f"
            "pdflatex -interaction nonstopmode -output-directory %o %f"))))
#+END_SRC

We also make sure to create the directory if it does not exist

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p org-ref-pdf-directory)
  (make-directory org-ref-pdf-directory t))
#+END_SRC

*** Set default key in Bibtex entries

When using tools like ~crossref-add-bibtex-entry~, we want a meaningful key to
be defined in the entries. I found this method in the ~org-ref~ config file.

#+BEGIN_SRC emacs-lisp
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

** ~ditaa~

~ditaa~ is a command-line utility, packed with ~org~, that allows conversion
from ascii art to bitmap. This is basically sorcery for taking notes. To enable
it, we have to explicitly load it to ~babel~:

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((ditaa . t)))
#+END_SRC

** Beamer export

We need to manually enable the export to Beamer option.

#+BEGIN_SRC emacs-lisp
(use-package ox-beamer)
#+END_SRC

** ~org-brain~

This package lets us collect all notes in a fortune of mind map that connects
each of the concepts. I'm trying to start taking notes on Computer Science
using this tool to create a huge mind map of all I learn. The recommended
configuration is:

#+BEGIN_SRC emacs-lisp
(use-package org-brain
  :ensure t
  :delight
  :init
  (setq org-brain-path "~/brain/entries")
  :config
  (setq org-id-track-globally t
	org-id-locations-file "~/.emacs.d/.org-id-locations"
	org-brain-visualize-default-choices 'all)
  :bind (("C-c b" . org-brain-visualize)))
#+END_SRC

* Other Major Modes
** ~erc~

~erc~ is a IRC client for Emacs. It is a wonderful tool worth checking out, and
requires really little configuration to make to be great.

*** Hide messages from inactive people

This snippet hides all the IRC messages that notify someone has joined, parted
or quitted if that user has been inactive for more than half an hour.

#+BEGIN_SRC emacs-lisp
(setq erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
(setq erc-lurker-threshold-time 1800)
#+END_SRC

*** Use the proper default nickname

~erc~ suggests a default nickname when logging in. ~agis~ is my username, if
you want to set another one just change that argument.

#+BEGIN_SRC emacs-lisp
(setq erc-nick "agis")
#+END_SRC
** ~w3m~

~w3m~ is a web browser. Yes, you read that right. No, it's not going to be a
substitute of your regular browser, but it's handy to have a fast way to query
things without going out of Emacs. It's super geeky, I know.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c w") 'w3m)
#+END_SRC

*** Set browser options

Basically, making it the default browser from Emacs, enable the cookies and
setting an Android agent to prevent clutter.

#+BEGIN_SRC emacs-lisp
;; (setq browse-url-browser-function 'w3m-goto-url-new-session)
(setq w3m-set-cookies t)
(setq w3m-user-agent "Mozilla/5.0 (Linux; U; Android 2.3.3; zh-tw; HTC_Pyramid
 Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile
 Safari/533.")
#+END_SRC

*** Giving permission to set cookies

I like to explicitly give permission to my frequent places to set cookies.

#+BEGIN_SRC emacs-lisp
(setq w3m-cookie-accept-domains '("reddit.com"))
#+END_SRC

*** Reddit shortcut

This function enables a shortcut that prompts the user for a subreddit, being
r/emacs the default one.

#+BEGIN_SRC emacs-lisp
(defun reddit (subreddit)
  "Opens the `subreddit' in w3m-new-session"
  (interactive
   (list
    (read-string "Enter subreddit (default: r/emacs): " nil nil "emacs" nil)))
  (browse-url (format "http://m.reddit.com/r/%s" subreddit))
  )
#+END_SRC


TODO: In my current setup, the colors are incredibly aggressive.
** ~mu4e~

This package allows to fetch and write emails from Emacs. Is it pushing a text
editor too far? Maybe. Also, take into account that it is part of ~mu~ and the
Emacs package is indeed included in it (not installed through a package
repository).

#+BEGIN_SRC emacs-lisp
(use-package mu4e
  :config
  ;; (setq mu4e-sent-messages-behavior 'delete)
  )
#+END_SRC
