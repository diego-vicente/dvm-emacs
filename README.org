#+TITLE:  My Emacs Configuration
#+AUTHOR: Diego Vicente Martín
#+EMAIL:  diegovicente@protonmail.com

* Introduction

The idea generating a new configuration file using ~org-mode~ and literate
programming is taken from [[https://youtu.be/SzA2YODtgK4][Harry Schwartz's talk about org-mode]]. When Emacs is
booted, all the source blocks from this file are used to generate the
configuration file.

To do this, the only thing needed is to have the configuration file parsed and
evaluated on startup. This can be done by moving ~init.el~ to the ~emacs.d~
directory. This can be done by executing =cp init.el ~/.emacs.d/init.el= on the
terminal. Note: this file assumes that this repository has been cloned to your
home, if you are going to install it elsewhere please edit ~init.el~ to find
this file.

* Basic Emacs Setup
** My information

All the relevant and personal information that Emacs needs. If you are going to
use it, needless to say to use your own information.

#+BEGIN_SRC emacs-lisp
(setq user-full-name "Diego Vicente"
      user-mail-address "diegovicente@protonmail.com"
      calendar-latitude 63.4
      calendar-longitude 10.4
      calendar-location-name "Trondheim, Norway")
#+END_SRC

** Add MELPA

The main package repository for Emacs. Must have, probably all the packages
that you need are already in MELPA.

#+BEGIN_SRC emacs-lisp
;; Add MELPA
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   '("MELPA" . "http://melpa.org/packages/") t)
  (package-initialize))
#+END_SRC

** Define my packages

Inspired by [[http://aaronbedra.com/emacs.d/][Aaron Bedra's Emacs 24 Configuration]], I use this variable to define
all the third-party packages that I use. 

#+BEGIN_SRC emacs-lisp
(defvar my-packages '(buffer-move
                      base16-theme
                      powerline
                      ido
                      helm
                      magit
                      projectile
                      flycheck
                      company
                      smartparens
                      jedi
                      intero
                      org-ref
                      org-bullets
                      git-gutter
                      git-gutter-fringe
                      smart-mode-line
                      ido-vertical-mode
                      auto-complete
                      expand-region
                      iedit
                      easy-escape
                      undo-tree
		      org-autolist
		      exec-path-from-shell
		      cyphejor
		      auctex
		      evil
		      evil-magit
                      relative-line-numbers
                      evil-mc
		      perspective
		      persp-projectile
		      yasnippet
                      )
  "My packages")
#+END_SRC

TODO: migrating this init to ~use-package~ should be able to get rid of this
hacky solution.

** Install my packages

Using the same variable defined before, check if the packages are installed and
install them if necessary.

#+BEGIN_SRC emacs-lisp
(defun packages-installed ()
  (cl-loop for pkg in my-packages
           when (not (package-installed-p pkg)) do (cl-return nil)
           finally (cl-return t)))

(unless (packages-installed)
  (message "%s" "Refreshing package database...")
  (package-refresh-contents)
  (dolist (pkg my-packages)
    (when (not (package-installed-p pkg))
      (package-install pkg))))
#+END_SRC

** Disable ~yes-or-no~ messages

For some reason, there are different types of confirmation prompts in
Emacs. One of them forces you to write "yes" and the other one only to press
"y", so I disable the first type.

#+BEGIN_SRC emacs-lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable startup message

I simply prefer to have a scratch buffer ready when I boot up, with ~org-mode~
running. Not a great Lisp developer myself (yet).

#+BEGIN_SRC emacs-lisp
(setq inhibit-splash-screen t
      initial-scratch-message nil
      initial-major-mode 'org-mode)
#+END_SRC

** Disable the warning when killing a buffer w/ process

When a buffer (i.e ~something.py~) has an associated process (in that case,
~Python~ for completion), Emacs will prompt you when trying to kill it, asking
for confirmation. I think it just interferes in my way, so I disable it as
well.

#+BEGIN_SRC emacs-lisp
(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+END_SRC

** Disable the bell

It is incredibly annoying after 20 minutes.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

** Set the backups folder

This feature is super useful sometimes, but it kills me to swarm my projects
with ~foo~~ files. That's why I set them to a backup directory and stop them
from polluting everywhere.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
  backup-by-copying t    ; Don't delink hardlinks
  version-control t      ; Use version numbers on backups
  delete-old-versions t  ; Automatically delete excess backups
  kept-new-versions 20   ; how many of the newest versions to keep
  kept-old-versions 5    ; and how many of the old
  )
#+END_SRC

** Fill the ~exec-path~ variable

I spent too much time until I figured this out. Since I mostly use GUI Emacs,
the ~exec-path~ variable is empty at start (it has not been started through
shell). That's why we need a function to loading the contents of ~$PATH~ to
Emacs variable and call it at start. This function was improved and uploaded as
package to MELPA, so to install it:

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :config (exec-path-from-shell-initialize))
#+END_SRC

** Insert new line without breaking

One of the things I really miss from vim is the shortcut ~o~, which was used to
insert a new line below the line in which the cursor is. To have the same
behavior in Emacs, I found this custom function that I bound to ~C-o~.

#+BEGIN_SRC emacs-lisp
(defun insert-new-line-below ()
  "Add a new line below the current line"
  (interactive)
  (let ((oldpos (point)))
    (end-of-line)
    (newline-and-indent)))

(global-set-key (kbd "C-o") 'insert-new-line-below)
#+END_SRC 

** Move buffers around

If we want to swap buffers location in frames, there's no fast way to do it in
Emacs by default. To do it, a good option that I found is to use ~buffer-move~
package, and use these key bindings.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :ensure t
  :bind (("C-x w <up>"    . buf-move-up)
	 ("C-x w <down>"  . buf-move-down)
	 ("C-x w <left>"  . buf-move-left)
	 ("C-x w <right>" . buf-move-right)))
#+END_SRC 

** Redefining sentences in Emacs

Emacs allows you to move in sentences using the commands ~M-a~ and ~M-e~ (to go
to the beginning or the end of the sentence). This is super useful for editing
text, but Emacs assumes that you always end sentences using a period and /two/
whitespaces, which... I actually don't. We can override this behavior with:

#+BEGIN_SRC emacs-lisp
(setq-default sentence-end-double-space nil)  
#+END_SRC

** Auto-fill comments

For our comments (only comments, not code) to be automatically filled
in programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp
(defun comment-auto-fill ()
      (setq-local comment-auto-fill-only-comments t)
      (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** More intuitive regions


This makes the visual region behave more like the contemporary concept of
highlighted text, that can be erased or overwritten as a whole.

#+BEGIN_SRC emacs-lisp
(delete-selection-mode t)
#+END_SRC

** Add functions to determine system

To know in which system we are running, I use these functions:

#+BEGIN_SRC emacs-lisp
(defun system-is-mac ()
  (interactive)
  (string-equal system-type "darwin"))

(defun system-is-linux ()
  (interactive)
  (string-equal system-type "gnu/linux"))
#+END_SRC

** Define keybindings to ~eval-buffer~ on init and open ~configuration.org~

Before this magical ~org~ configuration, it was easier to reload Emacs
configuration on the fly: ~M-x eval-buffer RET~. However, now the buffer to
evaluate is not this one, but ~.emacs.d/init.el~. That's why it's probably a
better idea to define a new keybinding that automatically reloads that buffer.

#+BEGIN_SRC emacs-lisp
(defun reload-emacs-configuration()
  "Reload the configuration"
  (interactive)
    (load "~/.emacs.d/init.el"))

(defun open-emacs-configuration ()
  "Open the configuration.org file in buffer"
  (interactive)
    (find-file "~/my-emacs/README.org"))

(global-set-key (kbd "C-c c r") 'reload-emacs-configuration)
(global-set-key (kbd "C-c c o") 'open-emacs-configuration)
#+END_SRC

** Scroll in the compilation buffer

It is really annoying to not have the last part of the output in the screen
when compiling. This automatically scrolls the buffer for you as the output is
printed. 

#+BEGIN_SRC emacs-lisp
(setq compilation-scroll-output t)
#+END_SRC

** Add other keybindings

Miscellaneous keybindings that don't really fit anywhere else.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c b") 'bookmark-jump)
#+END_SRC

* Graphical Interface
** Disabling GUI defaults

I always use Emacs in its GUI client, but because of the visual capabilities
and not the tools and bars. That's why I like to disable all the graphical
clutter.

#+BEGIN_SRC emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Setting default font

I really like how condensed is [[https://github.com/be5invis/Iosevka][Iosevka]], a coding typeface. Although it may look
weird in the beginning, then it's a joy to have all your code properly fitting
in the screen. However, lately I have really been into Liberation Mono.

#+BEGIN_SRC emacs-lisp
(set-default-font "Liberation Mono 13" t t)
#+END_SRC

** Setting my favorite theme

I really like [[https://github.com/chriskempson/base16][base16 color themes]] by Chris Kempson, specially
Eighties. However, lately I am really enjoying Oceanic. They are
available in MELPA. We also use the ~NO-CONFIRM~ flag when loading,
since the file tangling probably makes the code be not in order for
~custom-set-variables~ to do its job.

#+BEGIN_SRC emacs-lisp
(use-package base16-theme
  :ensure t
  :config (load-theme 'base16-oceanicnext t))
#+END_SRC

** Setting the fringe color

I dont'like the fringe to have a different color than the background,
so I run this function at start to set the same color in it. However,
take into account that if you change themes on the fly you need to run
the function again (there is no hook for that).

#+BEGIN_SRC emacs-lisp
(defun set-fringe-as-background ()
  (set-face-attribute 'fringe nil
                      :foreground (face-foreground 'default)
                      :background (face-background 'default)))

(set-fringe-as-background)
#+END_SRC

** ~smart-mode-line~ configuration

~smart-mode-line~ allows us to do a greater configuration of the mode-line
without being as flashy (and accessible tbh). This is the bare-bones
configuration for the package, that makes it not even load a theme. Apart from
the mere aesthetics, I also configure the column number display and different
short names for my folders. The last part edits slightly the mode line by
adding a single white-space below the fringe, which helps when rendering.

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :ensure t
  :config 
  (progn 
    (sml/setup)
    (setq-default mode-line-format
      '(" %e"
	mode-line-front-space
	mode-line-mule-info
	mode-line-client
	mode-line-modified
	mode-line-remote
	mode-line-frame-identification
	mode-line-buffer-identification
	sml/pos-id-separator
	mode-line-position
	(vc-mode vc-mode)
	sml/pre-modes-separator
	mode-line-modes
	mode-line-misc-info
	mode-line-end-spaces))
    (my-mode-line-colors)
    (column-number-mode 1)
    (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/" ":DB:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/Projects/" ":PRJ:"))
    (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/org/" ":ORG:" ))
    (add-to-list 'sml/replacer-regexp-list '("^~/Dropbox/org/bibliography/"
					     ":BIB:" ))
    ))
#+END_SRC

It doesn't load a theme because the colors are not really suitable for the rest
of my color scheme, so I set a simple theme myself:

#+BEGIN_SRC emacs-lisp
(defun my-mode-line-colors ()
  "Define all the faces associated with the smart-mode-line."
  (set-face-attribute 'mode-line nil :box '(:line-width 5 :style nil))
  (set-face-attribute 'mode-line-inactive nil :box '(:line-width 5 :style nil))
  (base16-set-faces
    'base16-oceanicnext
    base16-oceanicnext-colors
    '(
      (mode-line-inactive   :background base01 
			    :box (:line-width 4
				  :color base01
				  :style nil))
      (sml/global           :foreground base07)
      (sml/filename         :foreground base0A)
      (sml/prefix           :foreground base09)
      (sml/git              :foreground base0D)
      (sml/modified         :foreground base08)
      (sml/outside-modified :background base07
			    :foreground base08)
      (mode-line            :background base02 
			    :box (:line-width 4
			          :color base02
		                  :style nil)))))
#+END_SRC

** Configure modes in mode line to be shorter

~cyphejor~ is a package that allows to make shorter names in the
mode-line. And, as you can see, my way to use it is maybe a little bit
aggressive.

#+BEGIN_SRC emacs-lisp
(use-package cyphejor
  :ensure t
  :config 
  (progn
    (setq
     cyphejor-rules
     '(:upcase
       ("bookmark"    "→")
       ("buffer"      "β")
       ("diff"        "Δ")
       ("dired"       "δ")
       ("emacs"       "ε")
       ("fundamental" "Ⓕ")
       ("inferior"    "i" :prefix)
       ("interaction" "i" :prefix)
       ("interactive" "i" :prefix)
       ("lisp"        "λ" :postfix)
       ("menu"        "▤" :postfix)
       ("haskell"     "λ=")
       ("mode"        "")
       ("package"     "↓")
       ("python"      "π")
       ("org"         "Ω")
       ("shell"       "sh" :postfix)
       ("text"        "ξ")))
    (cyphejor-mode 1)))
#+END_SRC

On the other hand, I use ~rich-minority~ to select which are the minor modes
that I am interested in. All the modes below are black listed, that is, they
don't appear in the mode line even if they are active. *Important*: I don't
install it or activate it because ~smart-mode-line~ does that already. Also
important, notice that all modes include a whitespace as the first
character. This is actually needed for ~rich-minority~ to find the mode

#+BEGIN_SRC emacs-lisp
(setq rm-blacklist (mapconcat 'identity 
			      '(" GitGutter" " Fill" " Autolist" " Undo-Tree" 
				" ARev" " Helm" " SP" " AC" " Fly"
				" Projectile.+" " Intero" " yas")
			      "\\|"))
#+END_SRC

** Highlight changed and uncommited lines

Use the ~git-gutter-fringe~ package for that. For me it's more than enough to
have it in programming modes and in ~org-mode~.

#+BEGIN_SRC emacs-lisp
(use-package git-gutter
  :ensure git-gutter-fringe
  :config
  (progn
    (setq-default left-fringe-width  20)
    (add-hook 'prog-mode-hook 'git-gutter-mode)
    (add-hook 'org-mode-hook 'git-gutter-mode)))
#+END_SRC

** Set the cursor as a vertical bar

This is less agressive than the default brick, for sure. Thanks [[https://github.com/Alexrs95][Alex]] for this
snippet!

#+BEGIN_SRC emacs-lisp
(setq-default cursor-type 'bar)
(base16-set-faces
   'base16-oceanicnext
   base16-oceanicnext-colors
     '((cursor :background base09)))
#+END_SRC

* Packages & Tools  
** ~ido~

~ido~ enables some fuzzy finders in different commands like ~find-file~ or
other buffer related commands. Probably ~helm~ is a better option but I still
have to properly configure it. This enables fuzzy search and enables it
everywhere.

#+BEGIN_SRC emacs-lisp
(use-package ido
  :ensure t
  :config 
  (progn
    (setq ido-enable-flex-matching t
      ido-enable-dot-prefix t
      ido-enable-tramp-completion t
      ido-everywhere t)
    (ido-mode 1)))
#+END_SRC

Also, I feel it's much easier to understand what's going on when the options
are displayed in a vertical list. The cleanest way to achieve this is using a
package. 

#+BEGIN_SRC emacs-lisp
(use-package ido-vertical-mode
  :ensure t
  :config 
  (progn
    (setq ido-vertical-define-keys 'C-n-C-p-up-and-down
          ido-vertical-show-count t)
    (ido-vertical-mode 1)))
#+END_SRC

I also like to enable ~ido~ in my ~M-x~ prompt, for which I use the package
~smex~, that builds on top of an ~ido~ buffer and shows the most relevant
commands without keybindings on a certain mode.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :ensure t
  :bind (("M-x" . smex)
	 ("M-X" . smex-major-mode-commands)
	 ("C-c C-c M-x" . execute-extended-command)))
#+END_SRC

** ~helm~

As I said, probably redundant to be used alongside ~ido~, but still has much
more places to be used.

#+BEGIN_SRC emacs-lisp
(use-package helm-config
  :ensure helm
  :config (helm-mode 1))
#+END_SRC

** ~magit~

A porcelain client for git. ~magit~ alone is a reason to use Emacs over
vi/vim. It is really wonderful to use and you should install right now. This
also binds the status function to ~C-x g~.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-x g" . magit-status)))
#+END_SRC

** ~projectile~

Enables different tools and functions to deal with files related to a
project. To work, it searches for a VCS and sets it as the root of a project. I
have it configured to ignore all files that has not been staged in the git
project. 

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :ensure t
  :config
  (progn (projectile-global-mode 1)
	 (setq projectile-use-git-grep t)))
#+END_SRC

** ~perspective~

This package lets us store the window distributions that we use and switch
between them. I like to use it with ~persp-projectile~, which creates
perspectives automatically integrating them with each project. To configure it:

#+BEGIN_SRC emacs-lisp
(use-package perspective
  :ensure t
  :config (persp-mode))

(use-package persp-projectile
  :ensure t
  :config 
  (set-face-attribute 'persp-selected-face nil
		      :foreground (plist-get base16-oceanicnext-colors :base0D))
  :bind (("C-c p n" . persp-next)
	 ("C-c p k" . kill-current-perspective)
	 :map projectile-mode-map))
#+END_SRC

This snippet also changes the color of the mode-line widget to a smoother one
and binds ~C-c p n~ to change next perspective to integrate better the
perspective and project management.

Now that we have defined this beautiful ~perspective~ + ~projectile~ combo, we
can tweak a bit more its integration: For example, we can override the
behavior of ~C-c p k~: by default it is ~projectile-kill-buffers~, that will
kill all buffers associated to a project. We can make it also delete the
associated perspective:

#+BEGIN_SRC emacs-lisp
(defun kill-current-perspective ()
  "Kill the current project buffers and close its perspective."
  (interactive)
  (persp-kill (persp-name persp-curr)))
#+END_SRC

It is important to use ~define-key~ to shadow ~projectile~'s own bindings.

** ~flycheck~

Checks syntax for different languages. Works wonders, even though sometimes has
to be configured because it really makes things slow.

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :config (add-hook 'prog-mode-hook #'flycheck-mode))
#+END_SRC

** ~flyspell~

Just like ~flycheck~, but it checks natural language in a text. Super useful
for note taking and other text edition, specially if you use Emacs for
everything like I do. ~flyspell~ is installed in new Emacs versions, but there
are no completion tools by default in macOS, so we need to install the ~aspell~
engine by running ~brew install aspell --with-lang-en~

To make ~flyspell~ not clash with different syntax in the same file (like for
example, LaTeX or ~org-mode~ one) we need the last hook message.


#+BEGIN_SRC emacs-lisp
(use-package flyspell
  :ensure t
  :config 
  (progn
    (setq ispell-program-name "aspell"
	  ispell-dictionary "english")
    (add-hook 'org-mode-hook (lambda () (setq ispell-parser 'tex)))))
#+END_SRC

In case I am writing a text in a different language, I can just use ~M-x
ispell-change-dictionary~. Emacs seems to have a wide enough range of
dictionaries preinstalled to suit my needs. Later in the configurations, hooks
are added to each of the major-modes where I want ~flyspell~ to work.

And this function prevents the spell checker to get inside source blocks in
~org~. 

#+BEGIN_SRC emacs-lisp
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let* ((rlt ad-return-value)
         (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (case-fold-search t)
         b e)
    (when ad-return-value
      (save-excursion
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t))))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

** ~auto-complete~

It is probably redundant with ~company~, but works like a charm for the Python
environment. This bare-bones config just enables auto completion for language
specific words and other words in the buffer, so it's not really super useful.
For language specific settings, check each of the langauge configs. Also, I
like to customize a bit the looks of the pop-up menu

#+BEGIN_SRC emacs-lisp
(use-package auto-complete-config
  :ensure auto-complete
  :config
  (progn 
    (ac-config-default)
    (setq ac-show-menu-immediately-on-auto-complete t)
    (set-face-attribute 'popup-summary-face nil :inherit 'popup-face)
    (set-face-attribute 'popup-tip-face nil 
			:foreground "#c0c5ce"
			:background "#4f5b66")))
#+END_SRC

** ~smartparens~

Auto-close parenthesis and other characters. Useful as it seems.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :ensure t
  :config (add-hook 'prog-mode-hook #'smartparens-mode))
#+END_SRC

** ~expand-region~

Expand region allows to select hierarchically different text regions. It is, in
a way, a replacement for vim text objects.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)))
#+END_SRC

** Bind ~shell~

I don't use shell as much as I did before customizing Emacs, but still a good
command line is the best option sometimes. Bound it to ~C-c t~

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c t") 'shell)
#+END_SRC

** ~eshell~

To use the native Emacs shell with a sexier prompt, we can use this design
posted in Reddit.

#+BEGIN_SRC emacs-lisp
(setq eshell-prompt-function
      (lambda ()
	(let ((blue (plist-get base16-oceanicnext-colors :base0D))
	      (purple (plist-get base16-oceanicnext-colors :base0E))
	      (cyan (plist-get base16-oceanicnext-colors :base0C))
	      (yellow (plist-get base16-oceanicnext-colors :base0D))
	      (orange (plist-get base16-oceanicnext-colors :base09))
	      (grey (plist-get base16-oceanicnext-colors :base05)))
	  (concat
	   (propertize "┌─[" 'face '(:foreground blue))
	   (propertize (user-login-name) 'face '(:foreground purple))
	   (propertize "@" 'face '(:foreground blue))
	   (propertize (system-name) 'face '(:foreground cyan))
	   (propertize "]──[" 'face '(:foreground blue))
	   (propertize (format-time-string "%H:%M" (current-time))
		       'face '(:foreground grey))
	   (propertize "]──[" 'face '(:foreground blue))
	   (propertize (concat (eshell/pwd)) 'face '(:foreground orange))
	   (propertize "]\n" 'face '(:foreground blue))
	   (propertize "└─>" 'face '(:foreground blue))
	   (propertize (if (= (user-uid) 0) " # " " $ ")
		       'face '(:foreground blue))
	   ))))
#+END_SRC

** ~iedit~

This tool allows us to edit all variable names at once just by entering a
single keystroke.

#+BEGIN_SRC emacs-lisp
(use-package iedit
  :ensure t
  :bind (("C-c i" . iedit-mode)))
#+END_SRC

** ~easy-escape~

Makes Lisp regular expressions more readable.

#+BEGIN_SRC emacs-lisp
(use-package easy-escape
  :ensure t
  :config 
  (progn
    (add-hook 'lisp-mode-hook 'easy-escape-minor-mode)
    (add-hook 'emacs-lisp-mode-hook 'easy-escape-minor-mode)
    (base16-set-faces
     'base16-oceanicnext
     base16-oceanicnext-colors
     '((easy-escape-face :foreground base08)))))
#+END_SRC

** ~undo-tree~

This awesome package enables a gret undo-redo system that includes creating new
undo-redo branches. It's really amazing.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config (global-undo-tree-mode))
#+END_SRC

** ~yasnippets~

This package is a template and snippet system for Emacs, inspired by the syntax
of TextMate.

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config 
  (progn 
    (add-to-list 'yas-snippet-dirs "~/my-emacs/snippets")
    (yas-global-mode 1)
    (advice-add 'yas--auto-fill-wrapper :override #'ignore)))
#+END_SRC

In the ~/snippets~ folder in this repository you can see my snippets
collection. A good guide to understand the syntax used is in [[https://joaotavora.github.io/yasnippet/snippet-development.html][the manual for
YASnippet]]. All the snippets are local to a certain mode (delimited by the name
of the folder in the collection) and their keys can be expanded using ~TAB~.

* Programming Modes
** Python

This Python config is inspired from [[https://www.youtube.com/watch?v=6BlTGPsjGJk][the talk given by Drew Werner]]. With this
setup, we want to have these features:
- Easy navigation through function definitions.
- Contextual documentation.
- Inline help for function calls.

*** Basic ~jedi~ setup

This snippet sets some variable that we are going to need to use ~jedi~
properly, specially variables that will 

#+BEGIN_SRC emacs-lisp
(defvar jedi-config:use-system-python nil
  "Will use system python and active environment for Jedi server.
May be necessary for some GUI environments (e.g., Mac OS X)")

(defvar jedi-config:with-virtualenv nil
  "Set to non-nil to point to a particular virtualenv.")

(defvar jedi-config:vcs-root-sentinel ".git")

(defvar jedi-config:python-module-sentinel "__init__.py")
#+END_SRC

*** Create a setup in the Python hook

All this setup from here is bounded to a hook, so keep that in mind if you
scrap parts of it.

#+BEGIN_SRC emacs-lisp
(add-hook
 'after-init-hook
 '(lambda ()

    ;; Jedi
    (require 'jedi)
#+END_SRC

*** Define the functions to get the root of a project

For setting up the auto-completion and context-sensitive suggestions, we need a
way to get the root of a project. The functions defined below to exactly
this, using the variables set before.

#+BEGIN_SRC emacs-lisp
    (defun get-project-root-with-file (buf repo-file &optional init-file)
      "Guesses that the python root is the less 'deep' of either:
         -- the root directory of the repository, or
         -- the directory before the first directory after the root
            having the init-file file (e.g., '__init__.py'."

      ;; make list of directories from root, removing empty
      (defun make-dir-list (path)
        (delq nil (mapcar (lambda (x) (and (not (string= x "")) x))
                          (split-string path "/"))))
      ;; convert a list of directories to a path starting at "/"
      (defun dir-list-to-path (dirs)
        (mapconcat 'identity (cons "" dirs) "/"))
      ;; a little something to try to find the "best" root directory
      (defun try-find-best-root (base-dir buffer-dir current)
        (cond
         (base-dir ;; traverse until we reach the base
          (try-find-best-root (cdr base-dir) (cdr buffer-dir)
                              (append current (list (car buffer-dir)))))

         (buffer-dir ;; try until we hit the current directory
          (let* ((next-dir (append current (list (car buffer-dir))))
                 (file-file (concat (dir-list-to-path next-dir) "/" init-file)))
            (if (file-exists-p file-file)
                (dir-list-to-path current)
              (try-find-best-root nil (cdr buffer-dir) next-dir))))

         (t nil)))

      (let* ((buffer-dir (expand-file-name (file-name-directory (buffer-file-name buf))))
             (vc-root-dir (vc-find-root buffer-dir repo-file)))
        (if (and init-file vc-root-dir)
            (try-find-best-root
             (make-dir-list (expand-file-name vc-root-dir))
             (make-dir-list buffer-dir)
             '())
          vc-root-dir))) ;; default to vc root if init file not given

    ;; Set this variable to find project root
    (defvar jedi-config:find-root-function 'get-project-root-with-file)

    (defun current-buffer-project-root ()
      (funcall jedi-config:find-root-function
               (current-buffer)
               jedi-config:vcs-root-sentinel
               jedi-config:python-module-sentinel))
#+END_SRC

*** Setting up the server args

To launch the server, we set some variables for it. In this snippet, we can
find how to set the root of the project (we will use the functions we just
defined) and which ~virtualenv~ to use.

#+BEGIN_SRC emacs-lisp
    (defun jedi-config:setup-server-args ()
      ;; little helper macro for building the arglist
      (defmacro add-args (arg-list arg-name arg-value)
        `(setq ,arg-list (append ,arg-list (list ,arg-name ,arg-value))))
      ;; and now define the args
      (let ((project-root (current-buffer-project-root)))

        (make-local-variable 'jedi:server-args)

        (when project-root
          (message (format "Adding system path: %s" project-root))
          (add-args jedi:server-args "--sys-path" project-root))

        (when jedi-config:with-virtualenv
          (message (format "Adding virtualenv: %s" jedi-config:with-virtualenv))
          (add-args jedi:server-args "--virtual-env" jedi-config:with-virtualenv))))
#+END_SRC

*** Set the Python executable

I particularly have it set to Python 3.

#+BEGIN_SRC emacs-lisp
    ;; Use system python
    (defun jedi-config:set-python-executable ()
      (set-exec-path-from-shell-PATH)
      (make-local-variable 'jedi:server-command)
      (set 'jedi:server-command
           (list (executable-find "python3") ;; may need help if running from GUI
                 (cadr default-jedi-server-command))))
#+END_SRC

*** Set the hooks for the mode

We need to set the ~auto-complete~ hook to fing the ~jedi~ backend, hook the
~jedi~ setup to Python and define the buffer specific variables in each of
them. 

#+BEGIN_SRC emacs-lisp
    ;; Now hook everything up
    ;; Hook up to autocomplete
    (add-to-list 'ac-sources 'ac-source-jedi-direct)

    ;; Enable Jedi setup on mode start
    (add-hook 'python-mode-hook 'jedi:setup)

    ;; Buffer-specific server options
    (add-hook 'python-mode-hook
              'jedi-config:setup-server-args)
    (when jedi-config:use-system-python
      (add-hook 'python-mode-hook
                'jedi-config:set-python-executable))
#+END_SRC

*** Personal setup of the mode

Last, define a couple of keybindings and make ~jedi~ suggest completion after
typing.

#+BEGIN_SRC emacs-lisp
    ;; And custom keybindings
    (defun jedi-config:setup-keys ()
      (local-set-key (kbd "M-.") 'jedi:goto-definition)
      (local-set-key (kbd "M-,") 'jedi:goto-definition-pop-marker)
      (local-set-key (kbd "M-?") 'jedi:show-doc)
      (local-set-key (kbd "M-/") 'jedi:get-in-function-call))

    ;; Don't let tooltip show up automatically
    ;; (setq jedi:get-in-function-call-delay 10000000)
    ;; Start completion at method dot
    (setq jedi:complete-on-dot t
	  python-shell-interpreter "python3")
    ;; Use custom keybinds
    (add-hook 'python-mode-hook 'jedi-config:setup-keys)

    (setq python-shell-interpreter "ipython"
	  python-shell-interpreter-args (if (system-is-mac)
					    "--matplotlib=osx --colors=Linux"
					  (if (system-is-linux)
					      "--gui=wx --matplotlib=wx --colors=Linux"))
	  python-shell-prompt-regexp "In \\[[0-9]+\\]: "
	  python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
	  python-shell-completion-setup-code
	    "from IPython.core.completerlib import module_completion"
	  python-shell-completion-module-string-code
	    "';'.join(module_completion('''%s'''))\n"
	  python-shell-completion-string-code
	    "';'.join(get_ipython().Completer.all_completions('''%s'''))\n")
))
#+END_SRC

** Haskell
*** Enable ~intero~

In my experience, trying to deal with ~haskell-mode~ head-on is a pain in the
ass, and makes programming really slow. However, ~intero~ is a package with
batteries-included that works wonders. The best idea is to install it and hook
it to Haskell.

#+BEGIN_SRC emacs-lisp
(use-package intero
  :ensure t
  :init   (setenv "PATH" (concat "/usr/local/bin/ghci" (getenv "PATH")))
  :config (add-hook 'haskell-mode-hook 'intero-mode))
#+END_SRC

** LaTeX

With this configuration, we try to aim for a WYSIWYG editor in Emacs. It
requires to have ~AUCTeX~ installed.

*** Basic ~AUCTeX~ setup

This snippet makes that the ~AUCTeX~ macros are loaded every time the editor
requires them.

#+BEGIN_SRC emacs-lisp
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq TeX-save-query nil)
;(setq TeX-PDF-mode t)
#+END_SRC 

*** Enable ~flyspell~ in Tex edition

Add the hook to enable it by default.

#+BEGIN_SRC emacs-lisp
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-buffer)
#+END_SRC

* ~org-mode~
** Basic setup and other habits
*** Enable ~auto-fill-mode~ in Emacs

I truly believe that code and other text files have to respect a 79 characters
per line bound. No, 120 is not enough. Of course, for me ~org-mode~ should also
be, so we enable this behaviour to be automatic. Also, keep in mind that Emacs
auto fills to 70 characters, so we have to manually set the 79 limit.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'auto-fill-mode)
(setq-default fill-column 79)
#+END_SRC

*** Ensure LaTeX export options

We need to ensure that the indentation is left unaltered when exporting to
LaTeX, and also to add several options for ~org-ref~ exporting to work properly

#+BEGIN_SRC emacs-lisp
(setq org-src-preserve-indentation t)

(setq org-latex-default-packages-alist
      (-remove-item
       '("" "hyperref" nil)
       org-latex-default-packages-alist))

(add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
(add-to-list 'org-latex-default-packages-alist
	     '("linktocpage,pdfstartview=FitH,colorlinks,
linkcolor=blue,anchorcolor=blue,
citecolor=blue,filecolor=blue,menucolor=blue,urlcolor=blue"
	       "hyperref" nil)
	     t)
#+END_SRC

*** Native ~TAB~ in source blocks

This option makes ~TAB~ work as if the keystroke was issued in the code's major
mode. 

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

*** Open source blocks in the same window

When editing source code in an ~org~ source block, we can open a new buffer to
edit the code in its major mode. This option makes it use the same window
instead of popping a new one.

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
#+END_SRC

*** Set the directory

I set my org-directory in Dropbox. In there is the agenda files as well.

#+BEGIN_SRC emacs-lisp
(setq org-directory "~/Dropbox/org")

(defun org-file-path (filename)
  "Return the absolute address of an org file, given its relative name."
  (concat (file-name-as-directory org-directory) filename))

(setq org-agenda-files (list (org-file-path "agenda.org")))
#+END_SRC

*** Better RET

While reading this post in [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][the Kitchin Research Group website]], I stumbled into
this package that allows a better behavior of ~RET~ in ~org-mode~. 

#+BEGIN_SRC emacs-lisp
(use-package org-autolist
  :ensure t
  :config (add-hook 'org-mode-hook (lambda () (org-autolist-mode))))
#+END_SRC

*** Formatting functions

I have defined several functions to help me format text using the org markup
language. When I have selected text, I can use those keybindings to surround
the text with the different signs.

#+BEGIN_SRC emacs-lisp
(defun org-mode-format-bold (&optional arg)
  "Surround the selected text with asterisks (bold)"
  (interactive "P")
  (insert-pair arg ?\* ?\*))

(defun org-mode-format-italics (&optional arg)
  "Surround the selcted text with forward slashes (italics)"
  (interactive "P")
  (insert-pair arg ?\/ ?\/))

(defun org-mode-format-tt (&optional arg)
  "Surround the selcted text with virgules (monotype)"
  (interactive "P")
  (insert-pair arg ?\~ ?\~))


(add-hook 'org-mode-hook
	  (lambda () 
	    (local-set-key (kbd "C-c f b") 'org-mode-format-bold)
	    (local-set-key (kbd "C-c f i") 'org-mode-format-italics)
	    (local-set-key (kbd "C-c f m") 'org-mode-format-tt)))
#+END_SRC

*** Keybinding for ~org-agenda~

I like to have an easy access to the agenda, so I'll just bind it to ~C-c a~.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c a") 'org-agenda)
#+END_SRC

** Graphical aspects
*** Use syntax highlight in source blocks

When writing source code on a block, if this variable is enabled it will use
the same syntax highlight as the mode supposed to deal with it.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

*** Enable ~org-bullets~

Enable ~org-bullets~ to make it clearer. Also, the defaults are maybe
a bit too much for me, so edit them.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :ensure t
  :config
  (progn
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
    (setq org-bullets-bullet-list
	  '("◉" "◎" "○" "○" "○" "○"))))
#+END_SRC

*** Custom ellipsis

Also, I don't really like ~...~ to be the symbol for an ~org~ ellipsis. I
prefer to set something much more visual:

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis " ⤵")
#+END_SRC

** Spell checking

Add spell checking by enabling ~flyspell~ in its buffers. The configuration for
~flyspell~ is above.

#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook 'flyspell-mode)
;(add-hook 'org-mode-hook 'flyspell-buffer)
#+END_SRC

** ~org-ref~

~org-ref~ is a great package that enables a great deal of references and
shortcuts in ~org-mode~ when exporting to different formats like HTML or
LaTeX. The configuration can be a bit of a pain in the ass:

*** Basic setup and default dirs

We require the packages and set the default for the bibliography notes, the
main ~.bib~ bibliography and the directory where the PDFs can be downloaded to.

#+BEGIN_SRC emacs-lisp
(use-package org-ref-pdf
  :ensure t)

(use-package org-ref-url-utils
  :ensure t)

(use-package org-ref
  :ensure t
  :config 
  (progn
    (setq org-ref-bibliography-notes "~/Dropbox/org/bibliography/notes.org"
	  org-ref-default-bibliography '("~/Dropbox/org/bibliography/main.bib")
	  org-ref-pdf-directory "~/Dropbox/org/bibliography/pdfs"
	  org-latex-pdf-process
	  '("pdflatex -interaction nonstopmode -output-directory %o %f"
	    "bibtex %b"
	    "pdflatex -interaction nonstopmode -output-directory %o %f"
	    "pdflatex -interaction nonstopmode -output-directory %o %f"))))
#+END_SRC 

We also make sure to create the directory if it does not exist

#+BEGIN_SRC emacs-lisp
(unless (file-exists-p org-ref-pdf-directory)
  (make-directory org-ref-pdf-directory t))
#+END_SRC


*** Set default key in Bibtex entries

When using tools like ~crossref-add-bibtex-entry~, we want a meaningful key to
be defined in the entries. I found this method in the ~org-ref~ config file.

#+BEGIN_SRC emacs-lisp
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

** ~ditaa~

~ditaa~ is a command-line utility, packed with ~org~, that allows conversion
from ascii art to bitmap. This is basically sorcery for taking notes. To enable
it, we have to explicitly load it to ~babel~:

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((ditaa . t)))
#+END_SRC

** Beamer export

We need to manually enable the export to Beamer option.

#+BEGIN_SRC emacs-lisp
(use-package ox-beamer)
#+END_SRC

* Other Major Modes
** ~erc~

~erc~ is a IRC client for Emacs. It is a wonderful tool worth checking out, and
requires really little configuration to make to be great.

*** Hide messages from inactive people

This snippet hides all the IRC messages that notify someone has joined, parted
or quitted if that user has been inactive for more than half an hour.

#+BEGIN_SRC emacs-lisp
(setq erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
(setq erc-lurker-threshold-time 1800)
#+END_SRC

*** Use the proper default nickname

~erc~ suggests a default nickname when logging in. ~agis~ is my username, if
you want to set another one just change that argument.

#+BEGIN_SRC emacs-lisp
(setq erc-nick "agis")
#+END_SRC
** ~w3m~

~w3m~ is a web browser. Yes, you read that right. No, it's not going to be a
substitute of your regular browser, but it's handy to have a fast way to query
things without going out of Emacs. It's super geeky, I know.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-c w") 'w3m)
#+END_SRC

*** Set browser options

Basically, making it the default browser from Emacs, enable the cookies and
setting an Android agent to prevent clutter.

#+BEGIN_SRC emacs-lisp
;; (setq browse-url-browser-function 'w3m-goto-url-new-session)
(setq w3m-set-cookies t)
(setq w3m-user-agent "Mozilla/5.0 (Linux; U; Android 2.3.3; zh-tw; HTC_Pyramid
 Build/GRI40) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile 
 Safari/533.")
#+END_SRC

*** Giving permission to set cookies

I like to explicitly give permission to my frequent places to set cookies.

#+BEGIN_SRC emacs-lisp
(setq w3m-cookie-accept-domains '("reddit.com"))
#+END_SRC

*** Reddit shortcut

This function enables a shortcut that prompts the user for a subreddit, being
r/emacs the default one.

#+BEGIN_SRC emacs-lisp
(defun reddit (subreddit)
  "Opens the `subreddit' in w3m-new-session"
  (interactive 
   (list
    (read-string "Enter subreddit (default: r/emacs): " nil nil "emacs" nil)))
  (browse-url (format "http://m.reddit.com/r/%s" subreddit))
  )
#+END_SRC


TODO: In my current setup, the colors are incredibly aggressive.

* ~evil~
:PROPERTIES:
:header-args: :tangle no
:END:      
** Basic setup

Just require and enable ~evil~ to add al the vim controls and modal editing to
Emacs.

#+BEGIN_SRC emacs-lisp
(require 'evil)
(evil-mode 1)
#+END_SRC

** ~ESC~ quits everything

To exit recursive editing, just quit everything using ~ESC~ key.

#+BEGIN_SRC emacs-lisp
(defun minibuffer-keyboard-quit ()
  "Abort recursive edit.
In Delete Selection mode, if the mark is active, just deactivate it;
then it takes a second \\[keyboard-quit] to abort the minibuffer."
  (interactive)
  (if (and delete-selection-mode transient-mark-mode mark-active)
      (setq deactivate-mark  t)
    (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
    (abort-recursive-edit)))
(define-key evil-normal-state-map [escape] 'keyboard-quit)
(define-key evil-visual-state-map [escape] 'keyboard-quit)
(define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
(define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit)
#+END_SRC

** Most of regular Emacs in insert mode

~evil-mode~ also overrides some of the shortcuts in insert mode. When I am in
insert mode, I just want to use my regular Emacs keybindings. This achieves it
(except for the use of ~ESC~ as a ~M~ prefix).

#+BEGIN_SRC emacs-lisp
(setcdr evil-insert-state-map nil)
(define-key evil-insert-state-map [escape] 'evil-normal-state)
#+END_SRC

** Other evil packages
*** ~evil-magit~

Enables all the shortcuts in Magit

#+BEGIN_SRC emacs-lisp
(require 'evil-magit)
#+END_SRC

