#+TITLE:  My Emacs Configuration
#+AUTHOR: Diego Vicente Martín
#+EMAIL:  mail@diego.codes

* Introduction

The idea generating a new configuration file using =org-mode= and literate
programming is taken from [[https://youtu.be/SzA2YODtgK4][Harry Schwartz's talk about org-mode]]. When Emacs is
booted, all the source blocks from this file are used to generate the
configuration file.

To do this, the only thing needed is to have the configuration file parsed and
evaluated on startup. This can be done by moving =init.el= to the =emacs.d=
directory. This can be done by executing =cp init.el =/.emacs.d/init.el= on the
terminal. Note: this file assumes that this repository has been cloned to your
home, if you are going to install it elsewhere please edit =init.el= to find
this file.

* Basic Emacs Setup
** My information

All the relevant and personal information that Emacs needs. If you are going to
use it, needless to say to use your own information.

#+BEGIN_SRC emacs-lisp :results silent
(setq user-full-name "Diego Vicente"
      calendar-latitude 40.33
      calendar-longitude -3.76
      calendar-location-name "Madrid, Spain")
#+END_SRC

** Add MELPA

The main package repository for Emacs. Must have, probably all the packages
that you need are already in MELPA. Also, check that it is HTTPS! We'll
elaborate on it in a bit.

#+BEGIN_SRC emacs-lisp :results silent
;; Add MELPA
(when (>= emacs-major-version 24)
  (require 'package)
  (add-to-list
   'package-archives
   '("MELPA" . "https://melpa.org/packages/") t))
#+END_SRC

** Making Emacs secure

Some safety tips regarding your editor are covered in the excellent article
[[https://glyph.twistedmatrix.com/2015/11/editor-malware.html][Your Text Editor is Malware]]. So, before going on with the configuration, let's
get some things straight. First of all, enable checking trust on TLS
connections.

#+BEGIN_SRC emacs-lisp :results silent
(setq tls-checktrust t)
#+END_SRC

Now that we have enabled this feature, Emacs can't fetch HTTPS anymore: Emacs
does not distribute trust root certificates. So let's try to put a remedy for
it. First, there are some things you need to install outside of Emacs: the
=certifi= package for =PyPI= using =python3 -m pip install --user certifi= and
=gnutls= by running =brew install gnutls= or =apt-get install gnutls-bin=. Once
we have everything set, we just need to tell Emacs where to search for the
tools: setting the =tls-program= variable.

#+BEGIN_SRC emacs-lisp :results silent
;; This snippet is ready to work in both UNIX-like and Windows OS
(let ((trustfile
       (replace-regexp-in-string
        "\\\\" "/"
        (replace-regexp-in-string
         "\n" ""
         (shell-command-to-string (concat "python3 -m certifi"))))))
  (setq tls-program
        (list
         (format "gnutls-cli%s --x509cafile %s -p %%p %%h"
                 (if (eq window-system 'w32) ".exe" "") trustfile)))
  (setq gnutls-verify-error t)
  (setq gnutls-trustfiles (list trustfile)))
#+END_SRC

And, just in case (specially since the blog post provided it), we can create a
function to check if this setup is properly done:

#+BEGIN_SRC emacs-lisp :results silent
(defun check-tls-config ()
  "Check for correctness in the TLS configuration for Emacs."
  (interactive)
  (let ((bad-hosts
         (cl-loop for bad
               in `("https://wrong.host.badssl.com/"
                    "https://self-signed.badssl.com/")
               if (condition-case e
                      (url-retrieve
                       bad (lambda (retrieved) t))
                    (error nil))
               collect bad)))
    (if bad-hosts
        (error (format "TLS misconfigured; retrieved %s ok" bad-hosts))
      (url-retrieve "https://badssl.com"
                    (lambda (retrieved) t)))))
#+END_SRC

Please note that it is *crucial* to have added MELPA as an HTTPS for this
secure configuration to work.

** Disable =yes-or-no= messages

For some reason, there are different types of confirmation prompts in
Emacs. One of them forces you to write "yes" and the other one only to press
"y", so I disable the first type.

#+BEGIN_SRC emacs-lisp :results silent
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Disable startup message

I simply prefer to have a scratch buffer ready when I boot up, with =org-mode=
running. Not a great Lisp developer myself (yet).

#+BEGIN_SRC emacs-lisp :results silent
(setq inhibit-splash-screen t
      initial-scratch-message nil
      initial-major-mode 'org-mode)
#+END_SRC

** Disable the warning when killing a buffer with process

When a buffer (i.e =something.py=) has an associated process (in that case,
=Python= for completion), Emacs will prompt you when trying to kill it, asking
for confirmation. I think it just interferes in my way, so I disable it as
well.

#+BEGIN_SRC emacs-lisp :results silent
(setq kill-buffer-query-functions
  (remq 'process-kill-buffer-query-function
         kill-buffer-query-functions))
#+END_SRC

** Disable the bell

It is incredibly annoying after 20 minutes.

#+BEGIN_SRC emacs-lisp :results silent
(setq ring-bell-function 'ignore)
#+END_SRC

** Fix scroll


Setting this values will force one-line scrolling everywhere (mouse and
keyboard), resulting most of the times in a smoother scrolling than the actual
smooth scrolling.

#+BEGIN_SRC emacs-lisp :results silent
(setq scroll-step            1
      scroll-conservatively  10000
	  mouse-wheel-scroll-amount '(1 ((shift) . 1))
      mouse-wheel-progressive-speed nil
      mouse-wheel-follow-mouse 't)
#+END_SRC

** Set the backups folder

This feature is super useful sometimes, but it kills me to swarm my projects
with =foo== files. That's why I set them to a backup directory and stop them
from polluting everywhere.

#+BEGIN_SRC emacs-lisp :results silent
(setq backup-directory-alist '(("." . "~/.emacs.d/backup"))
	  backup-by-copying t
	  version-control t
	  delete-old-versions t
	  kept-new-versions 20
	  kept-old-versions 5)
#+END_SRC

** Fill the =exec-path= variable

I spent too much time until I figured this out. Since I mostly use GUI Emacs,
the =exec-path= variable is empty at start (it has not been started through
shell). That's why we need a function to loading the contents of =$PATH= to
Emacs variable and call it at start. This function was improved and uploaded as
package to MELPA, so to install it:

#+BEGIN_SRC emacs-lisp :results silent
(use-package exec-path-from-shell
  :ensure t
  :demand t
  :config
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)
    (add-hook 'find-file-hook 'exec-path-from-shell-initialize)))
#+END_SRC

** Insert new line without breaking

One of the things I really miss from vim is the shortcut =o=, which was used to
insert a new line below the line in which the cursor is. To have the same
behavior in Emacs, I found this custom function that I bound to =C-o=.

#+BEGIN_SRC emacs-lisp :results silent
(defun insert-new-line-below ()
  "Add a new line below the current line"
  (interactive)
  (let ((oldpos (point)))
    (end-of-line)
    (newline-and-indent)))

(global-set-key (kbd "C-o") 'insert-new-line-below)
#+END_SRC

** Move buffers around

If we want to swap buffers location in frames, there's no fast way to do it in
Emacs by default. To do it, a good option that I found is to use =buffer-move=
package, and use these key bindings.

#+BEGIN_SRC emacs-lisp :results silent
(use-package buffer-move
  :ensure t
  :bind (("C-x w <up>"    . buf-move-up)
         ("C-x w <down>"  . buf-move-down)
         ("C-x w <left>"  . buf-move-left)
         ("C-x w <right>" . buf-move-right)))
#+END_SRC

** Redefining sentences in Emacs

Emacs allows you to move in sentences using the commands =M-a= and =M-e= (to go
to the beginning or the end of the sentence). This is super useful for editing
text, but Emacs assumes that you always end sentences using a period and /two/
whitespaces, which... I actually don't. We can override this behavior with:

#+BEGIN_SRC emacs-lisp :results silent
(setq-default sentence-end-double-space nil)
#+END_SRC

** Auto-fill comments

For our comments (only comments, not code) to be automatically filled
in programming modes, we can use this function:

#+BEGIN_SRC emacs-lisp :results silent
(defun comment-auto-fill ()
  (setq-local comment-auto-fill-only-comments t)
  (auto-fill-mode 1))

(add-hook 'prog-mode-hook 'comment-auto-fill)
#+END_SRC

** Increase or decrease font size across all buffers

Extracted from a file in [[https://github.com/purcell/emacs.d][Steve Purcell's Emacs configuration]], it is possible to
use this functions to increase or decrease the text scale in all Emacs.
Specially useful for presentations, demos and other shows alike.

#+BEGIN_SRC emacs-lisp :results silent
(defun font-name-replace-size (font-name new-size)
  (let ((parts (split-string font-name "-")))
    (setcar (nthcdr 7 parts) (format "%d" new-size))
    (mapconcat 'identity parts "-")))

(defun increment-default-font-height (delta)
  "Adjust the default font height by DELTA on every frame.
The pixel size of the frame is kept (approximately) the same.
DELTA should be a multiple of 10, in the units used by the
:height face attribute."
  (let* ((new-height (+ (face-attribute 'default :height) delta))
         (new-point-height (/ new-height 10)))
    (dolist (f (frame-list))
      (with-selected-frame f
        ;; Latest 'set-frame-font supports a "frames" arg, but
        ;; we cater to Emacs 23 by looping instead.
        (set-frame-font (font-name-replace-size (face-font 'default)
                                                new-point-height)
                        t)))
    (set-face-attribute 'default nil :height new-height)
    (message "default font size is now %d" new-point-height)))

(defun increase-default-font-height ()
  (interactive)
  (increment-default-font-height 10))

(defun decrease-default-font-height ()
  (interactive)
  (increment-default-font-height -10))

(global-set-key (kbd "C-M-=") 'increase-default-font-height)
(global-set-key (kbd "C-M--") 'decrease-default-font-height)
#+END_SRC

** More intuitive regions


This makes the visual region behave more like the contemporary concept of
highlighted text, that can be erased or overwritten as a whole.

#+BEGIN_SRC emacs-lisp :results silent
(delete-selection-mode t)
#+END_SRC

** Add functions to determine system

To know in which system we are running, I use these functions:

#+BEGIN_SRC emacs-lisp :results silent
(defun system-is-mac ()
  (interactive)
  (string-equal system-type "darwin"))

(defun system-is-linux ()
  (interactive)
  (string-equal system-type "gnu/linux"))

(defun system-is-chip ()
  (interactive)
  (string-equal system-name "chip"))
#+END_SRC

** Define keybindings to =eval-buffer= on init and open =README.org=

Before this magical =org= configuration, it was easier to reload Emacs
configuration on the fly: =M-x eval-buffer RET=. However, now the buffer to
evaluate is not this one, but =.emacs.d/init.el=. That's why it's probably a
better idea to define a new keybinding that automatically reloads that buffer.

#+BEGIN_SRC emacs-lisp :results silent
(defun reload-emacs-configuration()
  "Reload the configuration"
  (interactive)
    (load "~/.emacs.d/init.el"))

(defun open-emacs-configuration ()
  "Open the configuration.org file in buffer"
  (interactive)
    (find-file "~/my-emacs/README.org"))

(global-set-key (kbd "C-c c r") 'reload-emacs-configuration)
(global-set-key (kbd "C-c c o") 'open-emacs-configuration)
#+END_SRC

** Scroll in the compilation buffer

It is really annoying to not have the last part of the output in the screen
when compiling. This automatically scrolls the buffer for you as the output is
printed.

#+BEGIN_SRC emacs-lisp :results silent
(setq compilation-scroll-output t)
#+END_SRC

** Add other keybindings

Miscellaneous keybindings that don't really fit anywhere else. Also, not only
adding but removing some.

#+BEGIN_SRC emacs-lisp :results silent
(global-set-key (kbd "C-c b") 'bookmark-jump)
(global-set-key (kbd "M-j") 'mark-word)

(unbind-key "C-z")
#+END_SRC

* My own Emacs-Lisp functions
** Clean the buffer

This function cleans the buffer from trailing whitespaces, more than two
consecutive new lines and tabs.

#+BEGIN_SRC emacs-lisp :results silent
(defun my-clean-buffer ()
  "Cleans the buffer by re-indenting, removing tabs and trailing whitespace."
  (interactive)
  (delete-trailing-whitespace)
  (save-excursion
    (replace-regexp "^\n\\{3,\\}" "\n\n" nil (point-min) (point-max)))
  (untabify (point-min) (point-max)))

(global-set-key (kbd "C-c x") 'my-clean-buffer)
#+END_SRC

** Move to indentation or beginning of the line

By default, =C-c a= moves the cursor to the beginning of the line. If there is
indentation, usually you want to move to the beginning of the line after the
indentation, which is indeed bound by default to =M-m=. However, my muscle
memory seems to be unable to learn that those are two different actions, so
it's time to use some Emacs magic. =beginning-of-line-dwim= takes you to the
beginning of indentation, as =M-m= would do. If you are already there, it takes
you to the absolute beginning of the line.

#+BEGIN_SRC emacs-lisp :results silent
(defun beginning-of-line-dwim ()
  (interactive)
  "Move to beginning of indentation, if there move to beginning of line."
  (if (= (point) (progn (back-to-indentation) (point)))
      (beginning-of-line)))

(global-set-key (kbd "C-a") 'beginning-of-line-dwim)
#+END_SRC

** Set the fringe as the background

This function allows to set the fringe color the same as the background, which
makes it look flatter and more minimalist.

#+BEGIN_SRC emacs-lisp :results silent
(defun set-fringe-as-background ()
  "Force the fringe to have the same color as the background"
  (set-face-attribute 'fringe nil
                      :foreground (face-foreground 'default)
                      :background (face-background 'default)))
#+END_SRC

** A twist on killing lines

I have the strange (and probably detrimental) muscle memory of using
=kill-line= as a fast method for copying and pasting. However, this implies
that I find myself far too often using =C-k C-y=. For that reason, I just
wanted to merge these two options in a single keystroke. I bind it to =M-k=
because I usually don't move in sentences and I definitely don't kill
sentences; your mileage may vary.

#+BEGIN_SRC emacs-lisp :results silent
(defun dont-kill-line()
  "Copy fromm the point to the end of the line without deleting it."
  (interactive)
  (kill-line)
  (yank))

(global-set-key (kbd "M-k") 'dont-kill-line)
#+END_SRC

* Graphical Interface
** Disabling GUI defaults

I always use Emacs in its GUI client, but because of the visual capabilities
and not the tools and bars. That's why I like to disable all the graphical
clutter.

The first line disables the menu bar, but it is commented to allow the full
screen behavior in macOS.

#+BEGIN_SRC emacs-lisp :results silent
(if (not (system-is-mac)) (menu-bar-mode -1))

(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

** Setting default font

I really like how condensed is [[https://github.com/be5invis/Iosevka][Iosevka]], a coding typeface. Although it may look
weird in the beginning, then it's a joy to have all your code properly fitting
in the screen. However, lately I have really been into Liberation Mono, Fira
Mono, Office Code Pro and Roboto Mono. All great, readable fonts.

#+BEGIN_SRC emacs-lisp :results silent
;; (if (system-is-chip)
;;     (set-frame-font "Liberation Mono 8" t t)
;;   (if (system-is-mac)
;;       (set-frame-font "Roboto Mono 13" t t)
;;     (set-frame-font "Roboto Mono 11" t t)))
(set-face-attribute 'default nil :font "Roboto Mono")
#+END_SRC

** Highlight changed and uncommited lines

Use the =git-gutter-fringe= package for that. For me it's more than enough to
have it in programming modes and in =org-mode=.

#+BEGIN_SRC emacs-lisp :results silent
(use-package git-gutter
  :ensure git-gutter-fringe
  :config
  (add-hook 'prog-mode-hook 'git-gutter-mode)
  (add-hook 'org-mode-hook 'git-gutter-mode))
#+END_SRC

** Setting my favorite theme

After a long journey through several of the [[https://github.com/chriskempson/base16][base16 color themes]], =gruvbox=,
=doom= and other color schemes, I think I have finally found my endgame one of
the all-time classics: =solarized-light=. It has a great contrast, that does
not feel tiring on the eyes after a long time using it like some other light
themes, and it is stupidly pretty overall. Furthermore, it is a great Emacs
package that offers a lot of customization for different packages. The only
thing that actually annoys me is the fact that it changes the font in
=org-mode= headings by default (which is that variable I am setting to =t=).

#+BEGIN_SRC emacs-lisp :results silent
(use-package solarized-theme
  :ensure t
  :init
  (setq solarized-use-variable-pitch nil)
  :config
  (load-theme 'solarized-light t)
  (set-face-attribute 'org-block nil :background "#f9f2d9"))
#+END_SRC

** Mode-line configuration

After trying most of the alternatives available to customizing the mode-line
(=smart-mode-line=, =powerline=, =airline=, =spaceline=...), I finally settled
with this minimal configuration. These two packages, developed by the great
[[https://github.com/tarsius][Jonas Bernoulli]], provide a beautiful and simple mode-line that shows all the
information I need in a beautiful way, being less flashy and prone to errors
than other packages. The general mode-line aesthetics and distribution is
provided by =moody=, while =minions= provide an on-click menu to show minor
modes. While you might be thinking "on-click menu? Wasn't the point of all this
editor thing not to use the mouse?", just notice that the previous setup used
=delight= to hide all minor modes. This does the same thing, saving me the
effort of writing =:delight= in most package declarations and provides a nice
menu if I need to check the minor modes at some points.

#+BEGIN_SRC emacs-lisp :results silent
(use-package minions
  :ensure t
  :config
  (setq minions-mode-line-lighter "[+]")
  (minions-mode))

(use-package moody
  :ensure t
  :config
  (setq x-underline-at-descent-line t
		column-number-mode t)
  (moody-replace-mode-line-buffer-identification)
  (moody-replace-vc-mode)
  (let ((line (face-attribute 'mode-line :underline)))
    (set-face-attribute 'mode-line          nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :overline   line)
    (set-face-attribute 'mode-line-inactive nil :underline  line)
    (set-face-attribute 'mode-line          nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :box        nil)
    (set-face-attribute 'mode-line-inactive nil :background "#f9f2d9")))
#+END_SRC

** Set the cursor as a vertical bar

This is less agressive than the default brick, for sure. Thanks [[https://github.com/Alexrs95][Alex]] for this
snippet!

#+BEGIN_SRC emacs-lisp :results silent
(setq-default cursor-type 'bar)
#+END_SRC

** Adding icons with =all-the-icons=

This package comes with a set of icons gathered from different fonts, so they
can be used basically everywhere. At least in macOS, remember to install the
necessary fonts that come bundled in the package!

#+BEGIN_SRC emacs-lisp :results silent
(use-package all-the-icons
  :ensure t)
#+END_SRC

* Packages & Tools
** =which-key=

A beautiful package that helps a lot specially when you are new to Emacs. Every
time a key chord is started, it displays all possible outcomes in the
minibuffer.

#+BEGIN_SRC emacs-lisp :results silent
(use-package which-key
  :ensure t
  :config (which-key-mode))
#+END_SRC

** =dired=

Emacs' default directory system. It may feel weird first, but it is super
powerful. Its main feature is that it is a buffer. Yes, ok, everything is a
buffer in Emacs, but if you press =C-c C-q= in a dired buffer it turns into a
writeable buffer, so you can edit the directory files just as a regular Emacs
piece of text! I also like to have the details hidden. Also, I feel like it can
be useful to comment a bit on =dired-dwim-target=. This enables the dired's Do
What I Mean behavior, which means that if you try to rename a file with a
second buffer open, it will assume that you want to move it there. Same with
copy and other operations.

#+BEGIN_SRC emacs-lisp :results silent
(use-package dired
  :config
  (setq dired-dwim-target t)
  :hook (dired-mode . dired-hide-details-mode))
#+END_SRC

** =ivy=

After trying =ido= and =helm=, the only step left to try was =ivy=. The way it
works is more similar to =ido=: it is a completion engine but more minimalist
than =helm=, simpler and faster.

#+BEGIN_SRC emacs-lisp :results silent
(use-package ivy
  :ensure t
  :config
  (ivy-mode 1)
  (setq ivy-count-format "%d/%d ")

  :bind (("C-s" . swiper)
         ("C-c h f" . counsel-describe-function)
         ("C-c h v" . counsel-describe-variable)
         ("M-i" . counsel-imenu)
         :map ivy-minibuffer-map
         ("RET" . ivy-alt-done)
         ("C-j" . ivy-done)))
#+END_SRC

Apart from =ivy=, I also like to use other alternative packages that complement
it.

#+BEGIN_SRC emacs-lisp :results silent
(use-package ivy-rich
  :ensure t
  :after ivy
  :config
  (ivy-set-display-transformer 'ivy-switch-buffer
                               'ivy-rich-switch-buffer-transformer))
#+END_SRC

** =iy-go-to-char=

Mimic vim's =f= with this function. I bind it to =M-m= to because the default
function in there (=beginning-of-indentation=) is not necessary after adding
=beginning-of-line-dwim=.

#+BEGIN_SRC emacs-lisp :results silent
(use-package iy-go-to-char
  :ensure t
  :demand t
  :bind (("M-m" . iy-go-up-to-char)
         ("M-M" . iy-go-to-char)))
#+END_SRC

** =ws-butler=

Remove the trailing whitespaces from the lines that have been edited. The point
of removing only the ones from the lines edited is to preserve useful blames
and diffs in VCS.

#+BEGIN_SRC emacs-lisp :results silent
(use-package ws-butler
  :ensure t
  :config (ws-butler-global-mode 1))
#+END_SRC

** =magit=


A porcelain client for git. =magit= alone is a reason to use Emacs over
vi/vim. It is really wonderful to use and you should install right now. This
also binds the status function to =C-x g=.

#+BEGIN_SRC emacs-lisp :results silent
(use-package magit
  :ensure t
  :config
  (git-commit-turn-on-auto-fill)
  (add-hook 'git-commit-mode-hook (lambda () (setq-local fill-column 72)))
  :bind (("C-x g" . magit-status)))

(use-package magit-lfs
  :ensure t)
#+END_SRC

** =projectile=

Enables different tools and functions to deal with files related to a
project. To work, it searches for a VCS and sets it as the root of a project. I
have it configured to ignore all files that has not been staged in the git
project.

#+BEGIN_SRC emacs-lisp :results silent
(use-package projectile
  :ensure t
  :config
  (projectile-global-mode 1)
  (setq projectile-use-git-grep t))
#+END_SRC

Also, the extension =counsel-projectile= adds integration with =ivy=.

#+BEGIN_SRC emacs-lisp :results silent
(use-package counsel-projectile
  :ensure t
  :config (counsel-projectile-mode t))
#+END_SRC

** =flycheck=

Checks syntax for different languages. Works wonders, even though sometimes has
to be configured because it really makes things slow.

#+BEGIN_SRC emacs-lisp :results silent
(use-package flycheck
  :ensure t
  :config 
  (add-hook 'prog-mode-hook #'flycheck-mode)
  (set-face-underline 'flycheck-error '(:color "Red1" :style line)))
#+END_SRC

** =flyspell=

Just like =flycheck=, but it checks natural language in a text. Super useful
for note taking and other text edition, specially if you use Emacs for
everything like I do. =flyspell= is installed in new Emacs versions, but there
are no completion tools by default in macOS, so we need to install the =aspell=
engine by running =brew install aspell --with-lang-en=

To make =flyspell= not clash with different syntax in the same file (like for
example, LaTeX or =org-mode= one) we need the last hook message.


#+BEGIN_SRC emacs-lisp :results silent
(use-package flyspell
  :ensure t
  :config
  (setq ispell-program-name "aspell"
        ispell-dictionary "english")

  (defun change-dictionary-spanish ()
	(interactive)
	(ispell-change-dictionary "espanol"))

  (defun change-dictionary-english ()
	(interactive)
	(ispell-change-dictionary "english"))

  :hook (org-mode . (lambda () (setq ispell-parser 'tex)))
  :bind (:map org-mode-map
			  ("C-c d s" . change-dictionary-spanish)
			  ("C-c d e" . change-dictionary-english)))
#+END_SRC

In case I am writing a text in a different language, I can just use =M-x
ispell-change-dictionary=. Emacs seems to have a wide enough range of
dictionaries preinstalled to suit my needs. Later in the configurations, hooks
are added to each of the major-modes where I want =flyspell= to work.

And this function prevents the spell checker to get inside source blocks in
=org=.

#+BEGIN_SRC emacs-lisp :results silent
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let* ((rlt ad-return-value)
         (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
         (case-fold-search t)
         b e)
    (when ad-return-value
      (save-excursion
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t))))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

** =company=

It is a light-weight completion system, supposed to be faster and simpler than
good 'ol =auto-complete=.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company
  :ensure t
  :config (setq company-tooltip-align-annotations t))
#+END_SRC

** =lsp-mode=

For a super-powered auto-completion and documentation system, it is possible to
use Microsoft's very own Language Server Protocol in Emacs. Specific
configurations will be added in this block for convenience, instead of in each
language's own section. The package =lsp-ui= is used to give some graphic
goodies when using LSP.

#+BEGIN_SRC emacs-lisp :results silent
(use-package lsp-mode
  :ensure t
  :config
  (require 'lsp-imenu)
  (lsp-define-stdio-client lsp-python "python"
                           #'projectile-project-root
                           '("pyls"))

  :hook (lsp-after-open . lsp-enable-imenu)
        (python-mode . (lambda () (lsp-python-enable))))

(use-package lsp-ui
  :ensure t
  :config
  (setq lsp-ui-sideline-show-hover nil)
  (set-face-attribute 'lsp-ui-doc-background  nil :background "#f9f2d9")
  (set-face-attribute 'lsp-ui-sideline-global nil
					  :inherit 'shadow
					  :background "#f9f2d9")
  :hook (lsp-mode . lsp-ui-mode))

(use-package company-lsp
  :ensure t
  :demand t
  :config (push 'company-lsp company-backends))
#+END_SRC

** =smartparens=

Auto-close parenthesis and other characters. Useful as it seems. Also, I add a
new custom pair that makes it indent and pass the closing pair when a newline
is inserted right after a curly bracket. This is specially useful in C and Go.

#+BEGIN_SRC emacs-lisp :results silent
(use-package smartparens
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'smartparens-mode)
  (sp-pair "{" nil :post-handlers '(("||\n[i]" "RET"))))
#+END_SRC

** =expand-region=

Expand region allows to select hierarchically different text regions. It is, in
a way, a replacement for vim text objects.

#+BEGIN_SRC emacs-lisp :results silent
(use-package expand-region
  :ensure t
  :bind (("C-=" . er/expand-region)))
#+END_SRC

** =eshell=

I don't use shell as much as I did before customizing Emacs, but still a good
command line is the best option sometimes. Bound it to =C-c t= and use all the
shortcuts of Emacs inside of it!

#+BEGIN_SRC emacs-lisp :results silent
(global-set-key (kbd "C-c t") 'eshell)
#+END_SRC

I also configure a company back-end to get =fish=-like completion, that
provides suggestions based on previous commands.

#+BEGIN_SRC emacs-lisp :results silent
(use-package esh-autosuggest
  :hook (eshell-mode . esh-autosuggest-mode)
  :ensure t)
#+END_SRC

** =iedit=

This tool allows us to edit all variable names at once just by entering a
single keystroke.

#+BEGIN_SRC emacs-lisp :results silent
(use-package iedit
  :ensure t
  :bind (("C-c i" . iedit-mode)))
#+END_SRC

** =undo-tree=

This awesome package enables a gret undo-redo system that includes creating new
undo-redo branches. It's really amazing.

#+BEGIN_SRC emacs-lisp :results silent
(use-package undo-tree
  :ensure t
  :config (global-undo-tree-mode))
#+END_SRC

** =yasnippets=

This package is a template and snippet system for Emacs, inspired by the syntax
of TextMate.

#+BEGIN_SRC emacs-lisp :results silent
(use-package yasnippet
  :ensure t
  :config
  (add-to-list 'yas-snippet-dirs "~/my-emacs/snippets")
  (yas-global-mode 1)
  (advice-add 'yas--auto-fill-wrapper :override #'ignore))
#+END_SRC

In the =/snippets= folder in this repository you can see my snippets
collection. A good guide to understand the syntax used is in [[https://joaotavora.github.io/yasnippet/snippet-development.html][the manual for
YASnippet]]. All the snippets are local to a certain mode (delimited by the name
of the folder in the collection) and their keys can be expanded using =TAB=.

** =rainbow-delimiters=

This package turns the parenthesis into color pairs, which makes everything
easier (specially in Lisp)

#+BEGIN_SRC emacs-lisp :results silent
(use-package rainbow-delimiters
  :ensure t
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

* Programming Modes
** Python
*** Regular Python configuration

#+BEGIN_SRC emacs-lisp :results silent
(use-package elpy
  :ensure t
  :config
  (elpy-enable)
  (add-to-list 'python-shell-completion-native-disabled-interpreters "ipython")
  (setq python-shell-interpreter "ipython"
		python-shell-interpreter-args "-i --simple-prompt")
  (add-hook 'elpy-mode-hook (lambda () (highlight-indentation-mode -1))))
#+END_SRC

*** Package for Python docstrings

This package adds some nice features like automatic creation of docstrings and
highlighting in them. There is also another package for better highlight and
indentation of the comments.

#+BEGIN_SRC emacs-lisp :results silent
(use-package sphinx-doc
  :ensure t
  :hook (python-mode . sphinx-doc-mode))

(use-package python-docstring
  :ensure t
  :config (setq python-docstring-sentence-end-double-space nil)
  :hook (python-mode . python-docstring-mode))
#+END_SRC

*** Notebook configuration

#+BEGIN_SRC emacs-lisp :results silent
(use-package ein
  :ensure t
  :config
  :hook (ein:notebook-multilang-mode
		 . (lambda () (ws-butler-mode -1) (visual-line-mode)))
  :custom-face
  (ein:cell-input-area ((t (:background "#f9f2d9")))))
#+END_SRC

** Haskell
*** Enable =intero=

In my experience, trying to deal with =haskell-mode= head-on is a pain in the
ass, and makes programming really slow. However, =intero= is a package with
batteries-included that works wonders. The best idea is to install it and hook
it to Haskell.

#+BEGIN_SRC emacs-lisp :results silent
(use-package intero
  :ensure t
  :init (setenv "PATH" (concat "/usr/local/bin/ghci" (getenv "PATH")))
  :hook (haskell-mode . intero-mode))
#+END_SRC

*** Disable soft wrapping in profiling files

GHC generates =.prof= files, which sometimes tend to have really long lines. To
make it easier to read them, I like to disable line truncation for that file
extension. The problem is that, well, is not as straightforward as you may
think...

#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'find-file-hook
          (lambda ()
            (when (and (stringp buffer-file-name)
                       (string-match "\\.prof\\'" buffer-file-name))
              (toggle-truncate-lines))))
#+END_SRC

** Idris

Idris is a relatively new language: purely functional, general purpose, and
oriented to type development and with a type and totality checker integrated. I
think that it is a super interesting experiment but a good Emacs configuration
makes it look like absolute magic.

#+BEGIN_SRC emacs-lisp :results silent
(use-package idris-mode
  :ensure t
  :bind (:map idris-mode-map
              ("C-c C-a" . idris-add-clause)
              ("C-c C-s" . idris-case-split)
              ("C-c C-f" . idris-proof-search)))
#+END_SRC

With this config, we can use a type-define-refine cycle by using the keys =C-c
C-a= to add a clause associated with a type definition, =C-c C-s= to split
cases and =C-c C-f= to fill a hole if possible; which is easier for me to
remember.

** Go

I am a complete noob in Go, and I have been trying to hack a bit with it
lately. This is just a little disclaimer taking into account that this is just
a leisure configuration and if you are going to manage code on production maybe
you need a different configuration to face it.

*** Installing and configuring =go-mode=

The first recommendation for a Go major mode seems to be this one:

#+BEGIN_SRC emacs-lisp :results silent
(use-package go-mode
  :ensure t)
#+END_SRC

*** Set tab width

Since Go is not precisely characterized by its open-mindedness, we have to use
tabs in our code (sigh). So, at least, let's set its size to something that can
be read (4 instead 8 characters long)

#+BEGIN_SRC emacs-lisp :results silent
(setq-default tab-width 4)
#+END_SRC

*** Calling =go-fmt= on save

We can use hooks to automatically format our code according to the guidelines:

#+BEGIN_SRC emacs-lisp :results silent
(add-to-list 'exec-path "/Users/diego/go")
(add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

*** Adding the =company= backend

Making auto-completion work in Go requires:

#+BEGIN_SRC emacs-lisp :results silent
(use-package company-go
  :ensure t
  :config
  (add-hook 'go-mode-hook 'company-mode)
  (add-to-list 'company-backends 'company-go))
#+END_SRC

*** Viewing documentation in the minibuffer

Using =go-eldoc= we can see the declaration, arguments, return types, etc of
the functions we are using in our code.

#+BEGIN_SRC emacs-lisp :results silent
(use-package go-eldoc
  :ensure t
  :config (add-hook 'go-mode-hook 'go-eldoc-setup))
#+END_SRC

*** Enabling playgrounds in Emacs

Go playgrounds enable a kind of REPL, which is super useful when trying to
learn the language and fast iterate over some code snippets.

#+BEGIN_SRC emacs-lisp :results silent
(use-package go-playground
  :ensure t)
#+END_SRC

** Rust

More or less like Go's one, this is just a minimal configuration for the
language.

*** Basic major mode

#+BEGIN_SRC emacs-lisp :results silent
(use-package rust-mode
  :ensure t
  :config (setq rust-format-on-save t))
#+END_SRC

*** Enable =flycheck=

#+BEGIN_SRC emacs-lisp :results silent
(use-package flycheck-rust
  :ensure t
  :demand t
  :config (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
#+END_SRC

*** Enable the =company= backend

#+BEGIN_SRC emacs-lisp :results silent
(use-package racer
  :ensure t
  :demand t
  :config
  (add-hook 'rust-mode-hook #'racer-mode)
  (add-hook 'racer-mode-hook #'eldoc-mode)
  (add-hook 'racer-mode-hook #'company-mode)
  :bind (:map rust-mode-map
              ("TAB" . company-indent-or-complete-common)))
#+END_SRC

** LaTeX

With this configuration, we try to aim for a WYSIWYG editor in Emacs. It
requires to have =AUCTeX= installed.

*** Basic =AUCTeX= setup

This snippet makes that the =AUCTeX= macros are loaded every time the editor
requires them.

#+BEGIN_SRC emacs-lisp :results silent
(setq TeX-auto-save t)
(setq TeX-parse-self t)
(setq TeX-save-query nil)
(setq-default TeX-master nil)
;(setq TeX-PDF-mode t)
#+END_SRC

*** Enable =flyspell= in Tex edition

Add the hook to enable it by default.

#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'LaTeX-mode-hook 'flyspell-mode)
(add-hook 'LaTeX-mode-hook 'flyspell-buffer)
#+END_SRC

*** Enable auto-fill for Tex edition

We already enabled auto-fill for comments in programming modes, but in LaTeX is
more useful to directly have everything auto-filled.

#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'LaTeX-mode-hook 'auto-fill-mode)
#+END_SRC

*** Adding =company= support for Tex

Add the backend enable auto-completion for LaTeX files.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company-auctex
  :ensure t
  :config 
  (add-hook 'LaTeX-mode-hook 'company-mode)
  (company-auctex-init))
#+END_SRC

* =org-mode=
** Basic setup and other habits
*** Enable =auto-fill-mode= in Emacs

I truly believe that code and other text files have to respect a 79 characters
per line bound. No, 120 is not enough. Of course, for me =org-mode= should also
be, so we enable this behaviour to be automatic. Also, keep in mind that Emacs
auto fills to 70 characters, so we have to manually set the 79 limit.

#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'org-mode-hook 'auto-fill-mode)
(setq-default fill-column 79)
#+END_SRC

*** Ensure LaTeX export options

We need to ensure that the indentation is left unaltered when exporting to
LaTeX, and also to add several options for =org-ref= exporting to work properly

#+BEGIN_SRC emacs-lisp :results silent
(setq org-src-preserve-indentation t)

(setq org-latex-default-packages-alist
      (-remove-item
       '("" "hyperref" nil)
       org-latex-default-packages-alist))

(add-to-list 'org-latex-default-packages-alist '("" "natbib" "") t)
(add-to-list 'org-latex-default-packages-alist
             '("linktocpage,pdfstartview=FitH,colorlinks
-linkcolor=black,anchorcolor=black,
-citecolor=black,filecolor=blue,menucolor=black,urlcolor=blue"
               "hyperref" nil)
             t)
#+END_SRC

*** Load languages for source blocks

Some rough collection of languages that are loaded for use in my everyday
org-mode workflow.

#+BEGIN_SRC emacs-lisp :results silent
(org-babel-do-load-languages
 'org-babel-load-languages
 '(;; (shell . t)
   (python . t)))
#+END_SRC

In the same fashion, define the safe languages that require no explicit
confirmation of being executed.

#+BEGIN_SRC emacs-lisp :results silent
(defun my-org-confirm-babel-evaluate (lang body)
  (not (member lang '("emacs-lisp" "python" "sh" "dot"))))

(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
#+END_SRC

*** Native =TAB= in source blocks

This option makes =TAB= work as if the keystroke was issued in the code's major
mode.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-src-tab-acts-natively t)
#+END_SRC

*** Display inline images

A small piece of elisp extracted from [[https://joy.pm/post/2017-09-17-a_graphviz_primer/][The Joy of Programming]] to properly
display inline images in org.

#+BEGIN_SRC emacs-lisp :results silent
(defun my/fix-inline-images ()
  (when org-inline-image-overlays
    (org-redisplay-inline-images)))

(add-hook 'org-babel-after-execute-hook 'my/fix-inline-images)
(setq-default org-image-actual-width 620)
#+END_SRC

*** Set source blocks to export as listings

This little snippets ensures that org will export the source blocks in the
=lstlisting= environment and highlight the syntax when necessary.

#+BEGIN_SRC emacs-lisp :results silent
(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "color"))
(add-to-list 'org-latex-packages-alist '("" "listings"))
(setq org-latex-listings 'listings)
#+END_SRC

*** Set the directory

I set my org-directory in Dropbox. In there is the agenda files as well.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-directory "~/Dropbox/org")

(defun org-file-path (filename)
  "Return the absolute address of an org file, given its relative name."
  (concat (file-name-as-directory org-directory) filename))

(setq org-agenda-files (list (org-file-path "master.org")
                             (org-file-path "agenda.org")))
#+END_SRC

*** Add a planning file per project

I like the idea of having a file in the root of each project called
=planning.org=, in which I can put all the tasks, ideas, and other research I
perform about a project. In case I add =TODO= entries, meetings, or other
artifacts, I want them to appear in the agenda. For that reason, this functions
checks for possible planning files existing in my projects.

#+BEGIN_SRC emacs-lisp :results silent
(defun get-my-planning-files ()
  "Get a list of existing planning files per project."
  (let ((candidates (map 'list
						(lambda (x) (concat x "planning.org"))
						(projectile-relevant-known-projects))))
	(remove-if-not 'file-exists-p candidates)))

(defun update-planning-files ()
  "Update the org-agenda-files variable with the planning files per project."
  (interactive)
  (dolist (new-org-file (get-my-planning-files))
	(add-to-list 'org-agenda-files new-org-file)))

;; For some reason, the list seem to be overwritten during init
(add-hook 'after-init-hook 'update-planning-files)
#+END_SRC

*** Better RET

While reading this post in [[http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/][the Kitchin Research Group website]], I stumbled into
this package that allows a better behavior of =RET= in =org-mode=.

#+BEGIN_SRC emacs-lisp :results silent
(use-package org-autolist
  :ensure t
  :config (add-hook 'org-mode-hook (lambda () (org-autolist-mode))))
#+END_SRC

*** Formatting functions

I have defined several functions to help me format text using the org markup
language. When I have selected text, I can use those keybindings to surround
the text with the different signs.

#+BEGIN_SRC emacs-lisp :results silent
(defun org-mode-format-bold (&optional arg)
  "Surround the selected text with asterisks (bold)"
  (interactive "P")
  (insert-pair arg ?\* ?\*))

(defun org-mode-format-italics (&optional arg)
  "Surround the selcted text with forward slashes (italics)"
  (interactive "P")
  (insert-pair arg ?\/ ?\/))

(defun org-mode-format-tt (&optional arg)
  "Surround the selcted text with virgules (monotype)"
  (interactive "P")
  (insert-pair arg ?\= ?\=))


(add-hook 'org-mode-hook
          (lambda ()
            (local-set-key (kbd "C-c f b") 'org-mode-format-bold)
            (local-set-key (kbd "C-c f i") 'org-mode-format-italics)
            (local-set-key (kbd "C-c f m") 'org-mode-format-tt)
            (local-set-key (kbd "C-c f *") 'org-mode-format-bold)
            (local-set-key (kbd "C-c f /") 'org-mode-format-italics)
            (local-set-key (kbd "C-c f =") 'org-mode-format-tt)))
#+END_SRC

*** Keybinding for =org-agenda=

I like to have an easy access to the agenda, so I'll just bind it to =C-c a=.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-agenda-span 14)
(global-set-key (kbd "C-c a") 'org-agenda)
#+END_SRC

** Graphical aspects
*** Use syntax highlight in source blocks

When writing source code on a block, if this variable is enabled it will use
the same syntax highlight as the mode supposed to deal with it.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-src-fontify-natively t)
#+END_SRC

*** Enable =org-bullets=

Enable =org-bullets= to make it clearer. Also, the defaults are maybe
a bit too much for me, so edit them.

#+BEGIN_SRC emacs-lisp :results silent
(use-package org-bullets
  :ensure t
  :config
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode)))
  (setq org-bullets-bullet-list
        '("◉" "◎" "○" "○" "○" "○")))
#+END_SRC

*** Custom ellipsis

Also, I don't really like =...= to be the symbol for an =org= ellipsis. I
prefer to set something much more visual:

#+BEGIN_SRC emacs-lisp :results silent
(setq org-ellipsis " ⤵")
#+END_SRC

*** Pretty symbols

This setting will make subscripts (=x_{subscript}=) and superscripts
(=x^{superscript}=) appear in =org= in a WYSIWYG fashion.

#+BEGIN_SRC emacs-lisp :results silent
(setq-default org-pretty-entities t)
#+END_SRC

*** LaTeX blocks

To preview latex fragments, we need some quick set up to obtain proper quality
to read it in a Retina display.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-latex-create-formula-image-program 'dvisvgm)
#+END_SRC

** Spell checking

Add spell checking by enabling =flyspell= in its buffers. The configuration for
=flyspell= is above.

#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'org-mode-hook 'flyspell-mode)
;(add-hook 'org-mode-hook 'flyspell-buffer)
#+END_SRC

** =org-ref=

=org-ref= is a great package that enables a great deal of references and
shortcuts in =org-mode= when exporting to different formats like HTML or
LaTeX. The configuration can be a bit of a pain in the ass:

*** Basic setup and default dirs

We require the packages and set the default for the bibliography notes, the
main =.bib= bibliography and the directory where the PDFs can be downloaded to.

#+BEGIN_SRC emacs-lisp :results silent
;; (use-package org-ref-pdf
;;   :ensure t)

;; (use-package org-ref-url-utils
;;   :ensure t)

(use-package org-ref
  :ensure t
  :config
  (setq org-ref-bibliography-notes "~/Dropbox/org/bibliography/notes.org"
        org-ref-default-bibliography '("~/Dropbox/org/bibliography/main.bib")
        org-ref-pdf-directory "~/Dropbox/org/bibliography/pdfs"
		org-latex-prefer-user-labels t
        org-latex-pdf-process
        '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "bibtex %b"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
          "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f")))
#+END_SRC


We also make sure to create the directory if it does not exist

#+BEGIN_SRC emacs-lisp :results silent
(unless (file-exists-p org-ref-pdf-directory)
  (make-directory org-ref-pdf-directory t))
#+END_SRC

*** Set default key in Bibtex entries

When using tools like =crossref-add-bibtex-entry=, we want a meaningful key to
be defined in the entries. I found this method in the =org-ref= config file.

#+BEGIN_SRC emacs-lisp :results silent
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

** =org-brain=

This packages provides a way to create a kind of wiki / concept map using
org-mode. This is a second attempt at centralizing all the notes I have laying
around, not associated with a concrete project.

#+BEGIN_SRC emacs-lisp :results silent
(use-package org-brain
  :ensure t
  :init
  (setq org-brain-path "~/Documents/org-brain/"))
#+END_SRC

** =ditaa=

=ditaa= is a command-line utility, packed with =org=, that allows conversion
from ascii art to bitmap. This is basically sorcery for taking notes. To enable
it, we have to explicitly load it to =babel=:

#+BEGIN_SRC emacs-lisp :results silent
(org-babel-do-load-languages
 'org-babel-load-languages
 '((ditaa . t)))
#+END_SRC

** Diagrams using graphviz

My personal setup for generating fast diagrams in org-mode. Super useful when
one needs to take notes in class or other situations where a diagram is needed.

#+BEGIN_SRC emacs-lisp :results silent
(use-package graphviz-dot-mode
  :ensure t)

(org-babel-do-load-languages
 'org-babel-load-languages
 '((dot . t)))
#+END_SRC

** Export settings
*** Open PDFs using the appropriate viewer

I am not super fond of the default Emacs PDF viewer, so I prefer to set it to
Okular.

#+BEGIN_SRC emacs-lisp :results silent
(add-hook 'org-mode-hook
      '(lambda ()
         (delete '("\\.pdf\\'" . default) org-file-apps)
         (add-to-list 'org-file-apps '("\\.pdf\\'" . "okular %s"))))
#+END_SRC

*** Clean intermediate files.

Thanks to [[https://github.com/labellson][Dani]] for letting me know that it is possible to automatically delete
the intermediate files generated when exporting =org-mode= files. Just set the
file extensions of all the undesired files and Emacs will take care of it.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-latex-logfiles-extensions
	  '("lof" "lot" "tex=" "aux" "idx" "log" "out" "toc" "nav" "snm" "vrb"
		"dvi" "fdb_latexmk" "blg" "brf" "fls" "entoc" "ps" "spl" "bbl"))
#+END_SRC

*** IEEE export

For class assignments and who-knows-what in the future, I was able to integrate
a IEEE Conference template in org-mode export via Latex. To use it, just
include the =IEEEtran= class in your org file. It has not been thoroughly
tested, but its headers, index, abstract and general aesthetic works perfectly
out of the box.

#+BEGIN_SRC emacs-lisp :results silent
(add-to-list 'org-latex-classes
             '("IEEEtran" "\\documentclass[11pt]{IEEEtran}"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
             t)
#+END_SRC

*** Beamer export

We need to manually enable the export to Beamer option.

#+BEGIN_SRC emacs-lisp :results silent
(use-package ox-beamer)
#+END_SRC

*** Reveal.js export

This package allows for simple export to Reveal slides and includes the custom
style I defined in my [[https://raw.githubusercontent.com/DiegoVicen/org-css/master/reveal.css][=org-css=]] repository.

#+BEGIN_SRC emacs-lisp :results silent
(use-package ox-reveal
  :load-path "~/Utilities/org-reveal"
  :config
  (setq org-reveal-root "https://diego.codes/reveal.js"
		org-reveal-extra-css "https://diego.codes/org-css/reveal-theme.css"))
#+END_SRC

** My blog publishing configuration

To generate my blog, I used =hugo= and =org-mode= files. After some issues with
=hugo= and a few of its assumptions about how I used =org=, but above all after
being absolutely marvelled by =org='s power when exporting files, I decided to
migrate the setup to just a pure =org= exporting web-site. I crafted a custom
CSS style for the exporting and developed the following configuration, which
relies on the properties that =org-publish= provides.

#+BEGIN_SRC emacs-lisp :results silent
(use-package ox-publish
  :init
  (setq my-blog-header-file "~/Projects/blog/org/partials/header.html"
		my-blog-footer-file "~/Projects/blog/org/partials/footer.html"
		org-html-validation-link nil)

  ;; Load partials on memory
  (defun my-blog-header (arg)
	(with-temp-buffer
	  (insert-file-contents my-blog-header-file)
	  (buffer-string)))

  (defun my-blog-footer (arg)
	(with-temp-buffer
	  (insert-file-contents my-blog-footer-file)
	  (buffer-string)))

  (defun filter-local-links (link backend info)
	"Filter that converts all the /index.html links to /"
	(if (org-export-derived-backend-p backend 'html)
		(replace-regexp-in-string "/index.html" "/" link)))

  :config
  (setq org-publish-project-alist
		'(;; Publish the posts
		  ("blog-notes"
		   :base-directory "~/Projects/blog/org"
		   :base-extension "org"
		   :publishing-directory "~/Projects/blog/public"
		   :recursive t
		   :publishing-function org-html-publish-to-html
		   :headline-levels 4
		   :section-numbers nil
		   :html-head nil
		   :html-head-include-default-style nil
		   :html-head-include-scripts nil
		   :html-preamble my-blog-header
		   :html-postamble my-blog-footer
		   )

		  ;; For static files that should remain untouched
		  ("blog-static"
		   :base-directory "~/Projects/blog/org/"
		   :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf\\|eot\\|svg\\|woff\\|woff2\\|ttf"
		   :publishing-directory "~/Projects/blog/public"
		   :recursive t
		   :publishing-function org-publish-attachment
		   )

		  ;; Combine the two previous components in a single one
		  ("blog" :components ("blog-notes" "blog-static"))))

  (add-to-list 'org-export-filter-link-functions 'filter-local-links))
#+END_SRC

* Other Major Modes
** =markdown-mode=

Even though I am not a great fan, I am often forced to write Markdown more
often that I would like to. This is the minimal configuration I have for such
mode.

#+BEGIN_SRC emacs-lisp :results silent
(use-package markdown-mode
  :ensure t
  :hook (markdown-mode . visual-line-mode))
#+END_SRC

** =csv-mode=

Data science is hard, ok? You have to deal with huge and not super friendly
files. However, being stubborn and geek as a I am, I try to get into Excel/Calc
as few times as I can. The best approach (specially when using a second screen,
bigger than a laptop) was simply to use a mode that allows for markup and
alignment of =.csv= files. However, since it was sometimes dealing with files
too big to be completely aligned, I added a function to only align the visible
part of the file.

#+BEGIN_SRC emacs-lisp :results silent
(use-package csv-mode
  :ensure t
  :demand
  :config

  (defun csv-align-visible ()
	"Align only visible entries in csv-mode."
	(interactive)
	(csv-align-fields nil (window-start) (window-end)))

  ;; C-c C-a is already bound to align all fields, but can be too slow.
  :bind (:map csv-mode-map
			  ("C-c C-w" . 'csv-align-visible)))
#+END_SRC

** =bbdb=: The Insidious Big Brother's Database

One of the best known packages for contact management in Emacs.

#+BEGIN_SRC emacs-lisp :results silent
(use-package bbdb
  :ensure t)
#+END_SRC

** =erc=

=erc= is a IRC client for Emacs. It is a wonderful tool worth checking out, and
requires really little configuration to make to be great.

*** Hide messages from inactive people

This snippet hides all the IRC messages that notify someone has joined, parted
or quitted if that user has been inactive for more than half an hour.

#+BEGIN_SRC emacs-lisp :results silent
(setq erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
(setq erc-lurker-threshold-time 1800)
#+END_SRC

*** Use the proper default nickname

=erc= suggests a default nickname when logging in. =agis= is my username, if
you want to set another one just change that argument.

#+BEGIN_SRC emacs-lisp :results silent
(setq erc-nick "agis")
#+END_SRC

** =mu4e=

This package allows to fetch and write emails from Emacs. Is it pushing a text
editor too far? Maybe. This package is part of =mu= and it automatically
installs (or at least should) the Emacs package. Here, we load it on run-time
and make the configuration. The main part of the configuration should however
be in the =.offlineimaprc= file, which configures the tool that actually
fetches and downloads all the mail.

The configuration is not easy and it is absolutely not accessible for new Emacs
users: plenty of things are going to break and you will need to tinker a lot of
stuff. Be confident before spending an hour of your time downloading emails for
nothing.

*** Basic =mu4e= configuration

After setting a proper =offlineimap= configuration, it is important to add the
installation path of =mu4e= manually when requiring it. Set it to your default
email agent and tell Emacs all the necessary data to fetch and send email. Take
into account that sending is not by =offlineimap= and requires a different
configuration (apart from using =smtpmail= which comes bundled in Emacs). If
you have multiple accounts, you can change between them using your own version
of =my-mu4e-account-alist= as well as the function provided by the devs,
=my-mu4e-set-account=.

#+BEGIN_SRC emacs-lisp :results silent :tangle no
(use-package mu4e
  :demand t
  :init
  (add-to-list 'load-path "/usr/local/share/emacs/site-lisp/mu4e")

  :config
  (setq mail-user-agent 'mu4e-user-agent)
  (setq mu4e-get-mail-command "offlineimap"
        mu4e-completing-read-function 'ivy-completing-read)

  ;; Defaults to my personal mail
  (setq mu4e-sent-folder   "/Personal/Sent")
  (setq mu4e-trash-folder  "/Personal/Trash")
  (setq mu4e-drafts-folder "/Personal/Drafts")

  (setq message-send-mail-function 'smtpmail-send-it)

  (defvar my-mu4e-account-alist
    '(("Personal"
       (mu4e-sent-folder "/Personal/Sent")
       (user-mail-address "diegovicente@protonmail.com")
       (smtpmail-smtp-user "diegovicente@protonmail.com")
       (smtpmail-stream-type plain)
       (smtpmail-local-domain "127.0.0.1")
       (smtpmail-default-smtp-server "127.0.0.1")
       (smtpmail-smtp-server "127.0.0.1")
       (smtpmail-smtp-service 1025))
      ("UC3M"
       (mu4e-sent-folder "/University/[Gmail].Enviados")
       (user-mail-address "100317150@alumnos.uc3m.es")
       (smtpmail-smtp-user "100317150@alumnos.uc3m.es")
       (smtpmail-stream-type starttls)
       (smtpmail-local-domain "smtp.gmail.com")
       (smtpmail-default-smtp-server "smtp.gmail.com")
       (smtpmail-smtp-server "smtp.gmail.com")
       (smtpmail-smtp-service 587))
      ("Decide"
       (mu4e-sent-folder "/Decide/[Gmail].Enviados")
       (user-mail-address "diego.vicente@decidesoluciones.es")
       (smtpmail-smtp-user "diego.vicente@decidesoluciones.es")
       (smtpmail-stream-type starttls)
       (smtpmail-local-domain "smtp.gmail.com")
       (smtpmail-default-smtp-server "smtp.gmail.com")
       (smtpmail-smtp-server "smtp.gmail.com")
       (smtpmail-smtp-service 587))
      ))

  (defun my-mu4e-set-account ()
  "Set the account for composing a message.
     This function is taken from:
     https://www.djcbsoftware.nl/code/mu/mu4e/Multiple-accounts.html"
  (interactive)
  (let* ((account
          (if mu4e-compose-parent-message
              (let ((maildir (mu4e-message-field mu4e-compose-parent-message :maildir)))
                (string-match "/\\(.*?\\)/" maildir)
                (match-string 1 maildir))
            (completing-read (format "Compose with account: (%s) "
                                     (mapconcat #'(lambda (var) (car var))
                                                my-mu4e-account-alist "/"))
                             (mapcar #'(lambda (var) (car var)) my-mu4e-account-alist)
                             nil t nil nil (caar my-mu4e-account-alist))))
         (account-vars (cdr (assoc account my-mu4e-account-alist))))
    (if account-vars
        (mapc #'(lambda (var)
                  (set (car var) (cadr var)))
              account-vars)
      (error "No email account found"))))

  :bind (("C-c m" . mu4e))
  :hook (mu4e-compose-pre . my-mu4e-set-account))
#+END_SRC

*** Unread mail notifications in the mode-line

To get a simple unread email count in your mode-line, just use the package
=mu4e-alert= which basically does everything for you. This configuration also
includes a function to periodically check for new mails. It is a bit hacky, so
thank the gods that someone else has done it for you.

#+BEGIN_SRC emacs-lisp :results silent :tangle no
(use-package mu4e-alert
  :ensure t
  :demand t
  :after mu4e
  :init
  (setq mu4e-alert-interesting-mail-query
        (concat
         "flag:unread maildir:/Personal/INBOX "
         "OR "
         "flag:unread maildir:/Decide/INBOX "
         "OR "
         "flag:unread maildir:/University/INBOX"))
  (mu4e-alert-enable-mode-line-display)

  (defun refresh-mu4e-alert-mode-line ()
    (interactive)
    (mu4e~proc-kill)
    (mu4e-alert-enable-mode-line-display))

  (defun set-mu4e-alert-mode-line ()
	(interactive)
	(run-with-timer 0 60 'refresh-mu4e-alert-mode-line))

  :hook (after-init . set-mu4e-alert-mode-line))
#+END_SRC

*** Write rich-text emails in =org-mode=

Bringing the best of Emacs into your inbox, you can use =org-mime= to write
emails using the =org-mode= markup syntax, and it will allow you to seamlessly
export them to HTML and send them as beautiful formatted text without any
effort. Last part of the configuration has yet another hacky disclaimer: the
lack of a proper hook to make it automatic forces us to define some key
bindings in certain modes to make everything more comfortable.

#+BEGIN_SRC emacs-lisp :results silent :tangle no
(use-package org-mime
  :ensure t
  :after mu4e
  :config
  (setq org-mime-preserve-breaks nil)

  (defun mu4e-compose-org-mail ()
    (interactive)
    (mu4e-compose-new)
    (mu4e-org-mode))

  (defun htmlize-and-send ()
    "When in an org-mu4e-compose-org-mode message, htmlize and send it."
    (interactive)
    (org-mime-htmlize)
    (message-send-and-exit))

  :bind (:map mu4e-org-mode-map
              ("C-c C-c" . htmlize-and-send)
         ;; These next lines would not be necessary if we could set a custom
         ;; compose function to automatically activate mu4e-org-mode
         :map mu4e-main-mode-map
              ("c" . mu4e-compose-org-mail)
         :map mu4e-compose-mode-map
              ("C-c o" . mu4e-org-mode)))
#+END_SRC
